<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>学习/分享/记录</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-01-08T07:47:15.501Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>张xiao博</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FaceDetector</title>
    <link href="http://example.com/2022/01/07/OpenCV/FaceDetector/"/>
    <id>http://example.com/2022/01/07/OpenCV/FaceDetector/</id>
    <published>2022-01-07T01:48:49.000Z</published>
    <updated>2022-01-08T07:47:15.501Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-OpenCV-For-Android"><a href="#1-OpenCV-For-Android" class="headerlink" title="1. OpenCV For Android"></a>1. OpenCV For Android</h3><pre><code>OpenCV 官网地址 https://opencv.org/releases/ ,提供了Android 平台使用的SDKSDK For Android 均包含在官方提供的opencv moudle中。</code></pre><h3 id="2-官方例子face-detection-仅分析Native实现"><a href="#2-官方例子face-detection-仅分析Native实现" class="headerlink" title="2. 官方例子face-detection(仅分析Native实现)"></a>2. 官方例子face-detection(仅分析Native实现)</h3><h4 id="2-1-face-detection-默认使用了opencv-Camera1-org-opencv-android-JavaCameraView-，用来获取和显示数据，可以在face-detect-surface-view-xml中对View组件进行替换为如下"><a href="#2-1-face-detection-默认使用了opencv-Camera1-org-opencv-android-JavaCameraView-，用来获取和显示数据，可以在face-detect-surface-view-xml中对View组件进行替换为如下" class="headerlink" title="2.1 face-detection 默认使用了opencv Camera1 (org.opencv.android.JavaCameraView)，用来获取和显示数据，可以在face_detect_surface_view.xml中对View组件进行替换为如下"></a>2.1 face-detection 默认使用了opencv Camera1 (org.opencv.android.JavaCameraView)，用来获取和显示数据，可以在face_detect_surface_view.xml中对View组件进行替换为如下</h4><pre><code>    <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;org.opencv.android.JavaCamera2View<br>    android:<span class="hljs-attribute">layout_width</span>=<span class="hljs-string">&quot;fill_parent&quot;</span><br>    android:<span class="hljs-attribute">layout_height</span>=<span class="hljs-string">&quot;fill_parent&quot;</span><br>    android:<span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;@+id/fd_activity_surface_view&quot;</span> /&gt;<br></code></pre></td></tr></table></figure>    通过替换，可以使用Camera2中的接口来获取数据和显示View</code></pre><p><img src="./OpenCV_FaceDetector_xml.PNG" alt="FaceDetector_Camera2"></p><h4 id="2-2-编译和构建步骤"><a href="#2-2-编译和构建步骤" class="headerlink" title="2.2 编译和构建步骤"></a>2.2 编译和构建步骤</h4><h5 id="2-2-1-通过在face-detection模块的build-gradle配置Cmake编译时2个参数"><a href="#2-2-1-通过在face-detection模块的build-gradle配置Cmake编译时2个参数" class="headerlink" title="2.2.1 通过在face-detection模块的build.gradle配置Cmake编译时2个参数"></a>2.2.1 通过在face-detection模块的build.gradle配置Cmake编译时2个参数</h5><pre><code>      OpenCV_DIR //OpenCV的路径 作用：提供编译c代码时，需要用到OpenCV的头文件 位置：sdk/native/jni/include 以及需要引入的OpenCV依赖库       targets &quot;detection_based_tracker&quot;</code></pre><p><img src="./FaceDetector_gradle.PNG" alt="FaceDetector_Camera2"><br>          face-detection 默认引用opencv module，在通过构建脚本CMakeList.txt 编译os文件</p><h5 id="2-2-2-Cmake"><a href="#2-2-2-Cmake" class="headerlink" title="2.2.2 Cmake"></a>2.2.2 Cmake</h5><p>Cmake构建脚本，包含引入OpenCV，以及本仓库需要编译的cpp文件<br> <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">cmake_minimum_required</span><span class="hljs-params">(VERSION <span class="hljs-number">3.6</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">set</span><span class="hljs-params">(target detection_based_tracker)</span></span><br><span class="hljs-function"><span class="hljs-title">project</span><span class="hljs-params">($&#123;target&#125; CXX)</span></span> #已通过build.gradle中手动添加的target<br><span class="hljs-function"><span class="hljs-title">set</span><span class="hljs-params">(ANDROID_OPENCV_COMPONENTS <span class="hljs-string">&quot;opencv_java&quot;</span> CACHE STRING <span class="hljs-string">&quot;&quot;</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">message</span><span class="hljs-params">(STATUS <span class="hljs-string">&quot;ANDROID_ABI=$&#123;ANDROID_ABI&#125;&quot;</span>)</span></span>#通过在Build.gradle中配置ndk abi <span class="hljs-attribute">filter</span>,默认会全部编译<br><span class="hljs-function"><span class="hljs-title">find_package</span><span class="hljs-params">(OpenCV REQUIRED COMPONENTS $&#123;ANDROID_OPENCV_COMPONENTS&#125;)</span></span><br><span class="hljs-function"><span class="hljs-title">file</span><span class="hljs-params">(GLOB srcs *.cpp *.c)</span></span><br><span class="hljs-function"><span class="hljs-title">file</span><span class="hljs-params">(GLOB hdrs *.hpp *.h)</span></span><br><span class="hljs-function"><span class="hljs-title">include_directories</span><span class="hljs-params">(<span class="hljs-string">&quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;&quot;</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">add_library</span><span class="hljs-params">($&#123;target&#125; SHARED $&#123;srcs&#125; $&#123;hdrs&#125;)</span></span><br><span class="hljs-function"><span class="hljs-title">target_link_libraries</span><span class="hljs-params">($&#123;target&#125; $&#123;ANDROID_OPENCV_COMPONENTS&#125;)</span></span><br></code></pre></td></tr></table></figure></p><h5 id="2-2-3-Native以及JNI编写"><a href="#2-2-3-Native以及JNI编写" class="headerlink" title="2.2.3 Native以及JNI编写"></a>2.2.3 Native以及JNI编写</h5><pre><code>此处无特别注意之处，均为标准规范</code></pre><h3 id="3-Face-detection调整为library"><a href="#3-Face-detection调整为library" class="headerlink" title="3. Face-detection调整为library"></a>3. Face-detection调整为library</h3><pre><code>3.1 通过Camera2接口+ImageReader接口获取相机帧数据，通过OpenCV SDK中官方代码，将YUV420_888转换成为Mat3.2 通过OpenCV对Java接口对Mat数据进行旋转等操作，保证送入识别接口的Mat(灰度)方向正常3.3 此处相机分为前置后置，此处灵活处理</code></pre><p><img src="./Mat_Rotation.PNG" alt="FaceDetector_Camera2">    </p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h3><h4 id="4-1-我们可以将OpenCV已编译好的so库以及include头文件单独迁移出来，直接使用Native-load-方法直接调用。此方法可以加快构建工程速度，无需再次编译libopencv-java4-so"><a href="#4-1-我们可以将OpenCV已编译好的so库以及include头文件单独迁移出来，直接使用Native-load-方法直接调用。此方法可以加快构建工程速度，无需再次编译libopencv-java4-so" class="headerlink" title="4.1 我们可以将OpenCV已编译好的so库以及include头文件单独迁移出来，直接使用Native.load()方法直接调用。此方法可以加快构建工程速度，无需再次编译libopencv_java4.so"></a>4.1 我们可以将OpenCV已编译好的so库以及include头文件单独迁移出来，直接使用Native.load()方法直接调用。此方法可以加快构建工程速度，无需再次编译libopencv_java4.so</h4><h4 id="4-2-OpenCV-FaceDetection中Nativce方法传递参数时，传递的为Mat索引，此方法减少内存以及快速将Java层Mat传递给Nativce"><a href="#4-2-OpenCV-FaceDetection中Nativce方法传递参数时，传递的为Mat索引，此方法减少内存以及快速将Java层Mat传递给Nativce" class="headerlink" title="4.2 OpenCV FaceDetection中Nativce方法传递参数时，传递的为Mat索引，此方法减少内存以及快速将Java层Mat传递给Nativce."></a>4.2 OpenCV FaceDetection中Nativce方法传递参数时，传递的为Mat索引，此方法减少内存以及快速将Java层Mat传递给Nativce.</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">    <span class="hljs-comment">//第一个参数为灰度Mat,传递给Native的为Long型地址</span><br>    public void detect(Mat imageGray, MatOfRect faces) &#123;<br>        native<span class="hljs-constructor">Detect(<span class="hljs-params">mNativeObj</span>, <span class="hljs-params">imageGray</span>.<span class="hljs-params">getNativeObjAddr</span>()</span>, faces.get<span class="hljs-constructor">NativeObjAddr()</span>);<br>    &#125;<br><br>JNIEXPORT void JNICALL Java_org_opencv_samples_facedetect_DetectionBasedTracker_nativeDetect<br>(JNIEnv<span class="hljs-operator"> * </span>jenv, jclass, jlong thiz, jlong imageGray, jlong faces)<br>&#123;<br>    <span class="hljs-comment">//LOGD(&quot;Java_org_opencv_samples_facedetect_DetectionBasedTracker_nativeDetect&quot;);</span><br><br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        vector&lt;Rect&gt; RectFaces;<br>        <span class="hljs-comment">//*((Mat*)imageGray) 此处将地址索引再次转为Mat</span><br>        ((DetectorAgregator*)thiz)-&gt;tracker-&gt;process(*((Mat*)imageGray));<br>        ((DetectorAgregator*)thiz)-&gt;tracker-&gt;get<span class="hljs-constructor">Objects(RectFaces)</span>;<br>        *((Mat*)faces) = <span class="hljs-constructor">Mat(RectFaces, <span class="hljs-params">true</span>)</span>;<br>    &#125;<br>    catch(const cv::Exception&amp; e)<br>    &#123;<br>        <span class="hljs-constructor">LOGD(<span class="hljs-string">&quot;nativeCreateObject caught cv::Exception: %s&quot;</span>, <span class="hljs-params">e</span>.<span class="hljs-params">what</span>()</span>);<br>        jclass je = jenv-&gt;<span class="hljs-constructor">FindClass(<span class="hljs-string">&quot;org/opencv/core/CvException&quot;</span>)</span>;<br>        <span class="hljs-keyword">if</span>(!je)<br>            je = jenv-&gt;<span class="hljs-constructor">FindClass(<span class="hljs-string">&quot;java/lang/Exception&quot;</span>)</span>;<br>        jenv-&gt;<span class="hljs-constructor">ThrowNew(<span class="hljs-params">je</span>, <span class="hljs-params">e</span>.<span class="hljs-params">what</span>()</span>);<br>    &#125;<br>    catch (...)<br>    &#123;<br>        <span class="hljs-constructor">LOGD(<span class="hljs-string">&quot;nativeDetect caught unknown exception&quot;</span>)</span>;<br>        jclass je = jenv-&gt;<span class="hljs-constructor">FindClass(<span class="hljs-string">&quot;java/lang/Exception&quot;</span>)</span>;<br>        jenv-&gt;<span class="hljs-constructor">ThrowNew(<span class="hljs-params">je</span>, <span class="hljs-string">&quot;Unknown exception in JNI code DetectionBasedTracker.nativeDetect()&quot;</span>)</span>;<br>    &#125;<br>    <span class="hljs-comment">//LOGD(&quot;Java_org_opencv_samples_facedetect_DetectionBasedTracker_nativeDetect END&quot;);</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-如果其他Native库使用OpenCV，我们在传入灰度数据时，也可以将Native设计为Mat地址索引"><a href="#4-3-如果其他Native库使用OpenCV，我们在传入灰度数据时，也可以将Native设计为Mat地址索引" class="headerlink" title="4.3 如果其他Native库使用OpenCV，我们在传入灰度数据时，也可以将Native设计为Mat地址索引"></a>4.3 如果其他Native库使用OpenCV，我们在传入灰度数据时，也可以将Native设计为Mat地址索引</h4><h4 id="4-4-OpenCV-FaceDetector可以跟其他人脸Landmark库配合使用，例如：FaceAlignmentSeeta，dlib等，在进行人脸关键点识别时，均需要传递为灰度Mat以及需要人脸框"><a href="#4-4-OpenCV-FaceDetector可以跟其他人脸Landmark库配合使用，例如：FaceAlignmentSeeta，dlib等，在进行人脸关键点识别时，均需要传递为灰度Mat以及需要人脸框" class="headerlink" title="4.4 OpenCV FaceDetector可以跟其他人脸Landmark库配合使用，例如：FaceAlignmentSeeta，dlib等，在进行人脸关键点识别时，均需要传递为灰度Mat以及需要人脸框"></a>4.4 OpenCV FaceDetector可以跟其他人脸Landmark库配合使用，例如：FaceAlignmentSeeta，dlib等，在进行人脸关键点识别时，均需要传递为灰度Mat以及需要人脸框</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-OpenCV-For-Android&quot;&gt;&lt;a href=&quot;#1-OpenCV-For-Android&quot; class=&quot;headerlink&quot; title=&quot;1. OpenCV For Android&quot;&gt;&lt;/a&gt;1. OpenCV For Android&lt;/h3</summary>
      
    
    
    
    <category term="OpenCV" scheme="http://example.com/categories/OpenCV/"/>
    
    
    <category term="OpenCV" scheme="http://example.com/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>OpenGLES_FBO</title>
    <link href="http://example.com/2022/01/07/Android/OpelGLES/OpenGLES_FBO/"/>
    <id>http://example.com/2022/01/07/Android/OpelGLES/OpenGLES_FBO/</id>
    <published>2022-01-07T01:48:00.000Z</published>
    <updated>2022-01-08T05:06:37.727Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><pre><code> 1. Android系统默认渲染器 OpenGL,系统启动时，经过BootLoader启动，kernel启动----&gt;init进程启动核心进程（ServiceManager,zygote,OpenGL)----&gt;播放开机动画        OpenGL渲染管线的最后一个阶段就是帧缓冲区（FrameBuffer) 2. OpenGL渲染管线的最后阶段FrameBuffer,Android系统存在默认缓冲区（window-system-provided frame),用于屏幕显示。GPU往显示缓冲区写入数据时，屏幕会显示缓冲内容。        使用FBO可以让数据不渲染到屏幕上，渲染到离屏的Buffer中        Android中后台给视频添加水印，Camera实时滤镜，需要把原数据经过处理后保存但是不显示数据 3.对于默认的相机，使用系统提供的OpenGL渲染的帧缓冲区（OES），OpenGL所有渲染结果直接到达帧缓冲区----&gt;on-Srceen渲染方式       对于贴纸相机，使用帧缓冲区对象，OpenGL将提供给窗口的帧缓冲区重定向FBO之中 4. FBO提供缓冲区：颜色缓冲区，深度缓冲区，模板缓冲区        FBO提供2种绑定的对象：纹理图片(texture images) 和 渲染图像(renderbuffer images)         4.1 纹理绑定FBO,OpenGL执行渲染到纹理操作        4.2 渲染绑定FBO，OpenGL执行离屏渲染        4.3 通过GL_MAX_COLOR_ATTACHMENTS查询颜色缓冲区挂节点        4.4 纹理对象 glFramebufferTexture2D            渲染对象 glFramebufferRenderbuffer 5. FBO (Frame Buffer Object) 帧缓冲区对象，FBO本身不能用于渲染，只有添加了纹理或者渲染缓冲区后才能作为渲染目标             6. FBO 使用流程图</code></pre><p><img src="./Android_OpenGLES_OES.jpg" alt="FBO"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="1-搭建基本OpenGLES-FBO-仅输出-纹理对象"><a href="#1-搭建基本OpenGLES-FBO-仅输出-纹理对象" class="headerlink" title="1.搭建基本OpenGLES FBO 仅输出 纹理对象"></a>1.搭建基本OpenGLES FBO 仅输出 纹理对象</h4><h4 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h4> <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">protected</span> <span class="hljs-built_in">int</span>[] mFrameBuffers;<br><span class="hljs-keyword">protected</span> <span class="hljs-built_in">int</span>[] mFrameBufferTextures;<br></code></pre></td></tr></table></figure><h4 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GlUtil</span>.</span></span>check<span class="hljs-constructor">GlError(TAG, <span class="hljs-string">&quot;[onReady()][Start]&quot;</span>)</span>;<br>super.on<span class="hljs-constructor">Ready(<span class="hljs-params">width</span>, <span class="hljs-params">height</span>)</span>;<br><span class="hljs-keyword">if</span> (mFrameBuffers != null) &#123;<br>       destroy<span class="hljs-constructor">FrameBuffers()</span>;<br>&#125;<br>mFrameBuffers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-number">1</span>]</span>;<br><span class="hljs-comment">//1 创建fbo</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">GenFramebuffers(<span class="hljs-params">mFrameBuffers</span>.<span class="hljs-params">length</span>, <span class="hljs-params">mFrameBuffers</span>, 0)</span>;<br>mFrameBufferTextures = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span><span class="hljs-literal">[<span class="hljs-number">1</span>]</span>;<br><span class="hljs-comment">//2 创建fbo纹理</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GlUtil</span>.</span></span>gl<span class="hljs-constructor">ConfigureTextures(<span class="hljs-params">mFrameBufferTextures</span>)</span>;<br><span class="hljs-comment">//3 绑定纹理</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">BindTexture(GLES20.GL_TEXTURE_2D, <span class="hljs-params">mFrameBufferTextures</span>[0])</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">TexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA, <span class="hljs-params">mOutputWidth</span>, <span class="hljs-params">mOutputHeight</span>, 0, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, <span class="hljs-params">null</span>)</span>;<br><span class="hljs-comment">//4 fbo绑定纹理</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">BindFramebuffer(GLES20.GL_FRAMEBUFFER, <span class="hljs-params">mFrameBuffers</span>[0])</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">FramebufferTexture2D(GLES20.GL_FRAMEBUFFER, GLES20.GL_COLOR_ATTACHMENT0, GLES20.GL_TEXTURE_2D, <span class="hljs-params">mFrameBufferTextures</span>[0], 0)</span>;<br><span class="hljs-comment">//5 解绑</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">BindTexture(GLES20.GL_TEXTURE_2D, 0)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">BindFramebuffer(GLES20.GL_FRAMEBUFFER, 0)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GlUtil</span>.</span></span>check<span class="hljs-constructor">GlError(TAG, <span class="hljs-string">&quot;[onReady()][End]&quot;</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="2-使用FBO处理图片滤镜-自己创建FrameBuffer-同时输出到纹理对象，渲染对象"><a href="#2-使用FBO处理图片滤镜-自己创建FrameBuffer-同时输出到纹理对象，渲染对象" class="headerlink" title="2.使用FBO处理图片滤镜(自己创建FrameBuffer,同时输出到纹理对象，渲染对象)"></a>2.使用FBO处理图片滤镜(自己创建FrameBuffer,同时输出到纹理对象，渲染对象)</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void create<span class="hljs-constructor">Envi()</span> &#123;<br>       <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>d(TAG, <span class="hljs-string">&quot;[createEnvi]&quot;</span>);<br>       <span class="hljs-comment">//创建帧缓冲对象</span><br>       <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">GenFramebuffers(1, <span class="hljs-params">fFrame</span>, 0)</span>;<br><br>       <span class="hljs-comment">//创建渲染缓冲对象</span><br>       <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">GenRenderbuffers(1, <span class="hljs-params">fRender</span>, 0)</span>;<br>       <span class="hljs-comment">//相似地，我们打算把渲染缓冲对象绑定，这样所有后续渲染缓冲操作都会影响到当前的渲染缓冲对象</span><br>       <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">BindRenderbuffer(GLES20.GL_RENDERBUFFER, <span class="hljs-params">fRender</span>[0])</span>;<br>       <span class="hljs-comment">//创建一个深度和模板渲染缓冲对象</span><br>       <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">RenderbufferStorage(GLES20.GL_RENDERBUFFER, GLES20.GL_DEPTH_COMPONENT16, <span class="hljs-params">mBitmap</span>.<span class="hljs-params">getWidth</span>()</span>, mBitmap.get<span class="hljs-constructor">Height()</span>);<br>       <span class="hljs-comment">//附加帧缓冲 渲染缓冲对象附加到帧缓冲的深度和模板附件</span><br>       <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">FramebufferRenderbuffer(GLES20.GL_FRAMEBUFFER, GLES20.GL_DEPTH_ATTACHMENT, GLES20.GL_RENDERBUFFER, <span class="hljs-params">fRender</span>[0])</span>;<br>       <span class="hljs-comment">//解绑渲染缓冲</span><br>       <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">BindRenderbuffer(GLES20.GL_RENDERBUFFER, 0)</span>;<br><br><br>       <span class="hljs-comment">//fTexture size 2</span><br>       <span class="hljs-comment">//fTexture[0] 普通纹理（由bitmap转成)</span><br>       <span class="hljs-comment">//fTexture[1] 帧缓冲纹理(GLES20.glTextImage2D)</span><br>       <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">GenTextures(2, <span class="hljs-params">fTexture</span>, 0)</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">BindTexture(GLES20.GL_TEXTURE_2D, <span class="hljs-params">fTexture</span>[<span class="hljs-params">i</span>])</span>;<br>            <span class="hljs-keyword">if</span> (i<span class="hljs-operator"> == </span><span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLUtils</span>.</span></span>tex<span class="hljs-constructor">Image2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA, <span class="hljs-params">mBitmap</span>, 0)</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//纹理的维度设置为图片的大小,传递null作为纹理的data,只分配内存，不写入数据</span><br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">TexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA, <span class="hljs-params">mBitmap</span>.<span class="hljs-params">getWidth</span>()</span>, mBitmap.get<span class="hljs-constructor">Height()</span>, <span class="hljs-number">0</span>, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, null);<br>            &#125;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">TexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_NEAREST)</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">TexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR)</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">TexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_CLAMP_TO_EDGE)</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">TexParameterf(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_CLAMP_TO_EDGE)</span>;<br>       &#125;<br>       mBuffer = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ByteBuffer</span>.</span></span>allocate(mBitmap.get<span class="hljs-constructor">Width()</span><span class="hljs-operator"> * </span>mBitmap.get<span class="hljs-constructor">Height()</span><span class="hljs-operator"> * </span><span class="hljs-number">4</span>);<br>&#125; <br>    <br><span class="hljs-comment">//绑定执行</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">BindFramebuffer(GLES20.GL_FRAMEBUFFER, <span class="hljs-params">fFrame</span>[0])</span>;<br><br><span class="hljs-comment">//将创建好的帧缓冲纹理附加到帧缓冲 纹理对象</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">FramebufferTexture2D(GLES20.GL_FRAMEBUFFER, GLES20.GL_COLOR_ATTACHMENT0, GLES20.GL_TEXTURE_2D, <span class="hljs-params">fTexture</span>[1], 0)</span>;<br><br><span class="hljs-comment">//FBO挂接 渲染对象 Renderbuffer 渲染缓冲 对象的一大优点是，它以OpenGL原生渲染格式储存它的数据，因此在离屏渲染到帧缓冲的时候，这些数据就相当于被优化过的了</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">FramebufferRenderbuffer(GLES20.GL_FRAMEBUFFER, GLES20.GL_DEPTH_ATTACHMENT, GLES20.GL_RENDERBUFFER, <span class="hljs-params">fRender</span>[0])</span>;<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">Viewport(0, 0, <span class="hljs-params">mBitmap</span>.<span class="hljs-params">getWidth</span>()</span>, mBitmap.get<span class="hljs-constructor">Height()</span>);<br>mFilter.set<span class="hljs-constructor">TextureId(<span class="hljs-params">fTexture</span>[0])</span>;<br>mFilter.draw<span class="hljs-literal">()</span>;    <br><br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">ReadPixels(0, 0, <span class="hljs-params">mBitmap</span>.<span class="hljs-params">getWidth</span>()</span>, mBitmap.get<span class="hljs-constructor">Height()</span>, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, mBuffer);<br><span class="hljs-keyword">if</span> (mCallback != null) &#123;<br>       mCallback.on<span class="hljs-constructor">Call(<span class="hljs-params">mBuffer</span>)</span>;<br>&#125;<br><br>delete<span class="hljs-constructor">Envi()</span>;<br>mBitmap.recycle<span class="hljs-literal">()</span>;<br></code></pre></td></tr></table></figure><h4 id="3-使用FBO处理相机纹理"><a href="#3-使用FBO处理相机纹理" class="headerlink" title="3. 使用FBO处理相机纹理"></a>3. 使用FBO处理相机纹理</h4><h5 id="3-1获取相机纹理后，最后返回步骤1中生成的mFrameBufferTextures-0-，即可对相机纹理进行多个滤镜或者变换处理"><a href="#3-1获取相机纹理后，最后返回步骤1中生成的mFrameBufferTextures-0-，即可对相机纹理进行多个滤镜或者变换处理" class="headerlink" title="3.1获取相机纹理后，最后返回步骤1中生成的mFrameBufferTextures[0]，即可对相机纹理进行多个滤镜或者变换处理"></a>3.1获取相机纹理后，最后返回步骤1中生成的mFrameBufferTextures[0]，即可对相机纹理进行多个滤镜或者变换处理</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GlUtil</span>.</span></span>check<span class="hljs-constructor">GlError(TAG, <span class="hljs-string">&quot;[onDrawFrame()][Start]&quot;</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">Viewport(<span class="hljs-params">left_margin</span>, 0, <span class="hljs-params">mOutputWidth</span>, <span class="hljs-params">mOutputHeight</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">BindFramebuffer(GLES20.GL_FRAMEBUFFER, <span class="hljs-params">mFrameBuffers</span>[0])</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">UseProgram(<span class="hljs-params">mGLProgramId</span>)</span>;<br><br>mGLVertexBuffer.position(<span class="hljs-number">0</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">VertexAttribPointer(<span class="hljs-params">vPosition</span>, 2, GLES20.GL_FLOAT, <span class="hljs-params">false</span>, 0, <span class="hljs-params">mGLVertexBuffer</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">EnableVertexAttribArray(<span class="hljs-params">vPosition</span>)</span>;<br>mGLTextureBuffer.position(<span class="hljs-number">0</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">VertexAttribPointer(<span class="hljs-params">vCoord</span>, 2, GLES20.GL_FLOAT, <span class="hljs-params">false</span>, 0, <span class="hljs-params">mGLTextureBuffer</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">EnableVertexAttribArray(<span class="hljs-params">vCoord</span>)</span>;<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">UniformMatrix4fv(<span class="hljs-params">vMatrix</span>, 1, <span class="hljs-params">false</span>, <span class="hljs-params">matrix</span>, 0)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">ActiveTexture(GLES20.GL_TEXTURE0)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">BindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, <span class="hljs-params">textureId</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">Uniform1i(<span class="hljs-params">vTexture</span>, 0)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">DrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">BindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, 0)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">BindFramebuffer(GLES20.GL_FRAMEBUFFER, 0)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GlUtil</span>.</span></span>check<span class="hljs-constructor">GlError(TAG, <span class="hljs-string">&quot;[onDrawFrame()][Start]&quot;</span>)</span>;<br>return mFrameBufferTextures<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>;<span class="hljs-comment">//返回创建好的纹理对象-----&gt;进行后续的操作</span><br></code></pre></td></tr></table></figure><h4 id="4-释放"><a href="#4-释放" class="headerlink" title="4.释放"></a>4.释放</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"> <span class="hljs-keyword">private</span> void delete<span class="hljs-constructor">Envi()</span> &#123;<br>     <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">DeleteTextures(2, <span class="hljs-params">fTexture</span>, 0)</span>;<br>     <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">DeleteRenderbuffers(1, <span class="hljs-params">fRender</span>, 0)</span>;<br>     <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">DeleteFramebuffers(1, <span class="hljs-params">fFrame</span>, 0)</span>;<br> &#125;<br><br><br><span class="hljs-keyword">private</span> void destroy<span class="hljs-constructor">FrameBuffers()</span> &#123;<br>     <span class="hljs-keyword">if</span> (mFrameBufferTextures != null) &#123;<br>         <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">DeleteTextures(1, <span class="hljs-params">mFrameBufferTextures</span>, 0)</span>;<br>         mFrameBufferTextures = null;<br>     &#125;<br><br>     <span class="hljs-keyword">if</span> (mFrameBuffers != null) &#123;<br>         <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GLES20</span>.</span></span>gl<span class="hljs-constructor">DeleteFramebuffers(1, <span class="hljs-params">mFrameBuffers</span>, 0)</span>;<br>         mFrameBuffers = null;<br>     &#125;<br> &#125;<br><br></code></pre></td></tr></table></figure><h4 id="5-参考"><a href="#5-参考" class="headerlink" title="5.参考"></a>5.参考</h4><ol><li><a href="https://github.com/MrYeLiang/Android-OpenGL-Filter">MrYeLiang Android-OpenGL-Filter 相机纹理3次FBO纹理变化</a></li><li><a href="https://github.com/doggycoder/AndroidOpenGLDemo">湖广午王 AndroidOpenGLDemo FBO 图片灰度滤镜</a> </li></ol><h4 id="6-Camera2-GLSurfaceView-FBO"><a href="#6-Camera2-GLSurfaceView-FBO" class="headerlink" title="6.Camera2+GLSurfaceView+FBO"></a>6.Camera2+GLSurfaceView+FBO</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;基本知识&quot;&gt;&lt;a href=&quot;#基本知识&quot; class=&quot;headerlink&quot; title=&quot;基本知识&quot;&gt;&lt;/a&gt;基本知识&lt;/h3&gt;&lt;pre&gt;&lt;code&gt; 1. Android系统默认渲染器 OpenGL,系统启动时，经过BootLoader启动，kernel启</summary>
      
    
    
    
    <category term="OpenGLES" scheme="http://example.com/categories/OpenGLES/"/>
    
    
    <category term="OpenGLES" scheme="http://example.com/tags/OpenGLES/"/>
    
  </entry>
  
  <entry>
    <title>Camera_GlSurfaceView</title>
    <link href="http://example.com/2022/01/07/Android/Camera2/Camera2_GlSurfaceView/"/>
    <id>http://example.com/2022/01/07/Android/Camera2/Camera2_GlSurfaceView/</id>
    <published>2022-01-07T01:46:14.000Z</published>
    <updated>2022-01-08T03:21:10.841Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念:"></a>基本概念:</h3><h4 id="屏幕方向"><a href="#屏幕方向" class="headerlink" title="屏幕方向"></a>屏幕方向</h4><p><img src="./OpenGLES_Camera_Screen_Orientaion.png" alt="ScreenOrientation"></p><h4 id="ScreenOrientation-0度"><a href="#ScreenOrientation-0度" class="headerlink" title="ScreenOrientation:0度"></a>ScreenOrientation:0度</h4><p><img src="./Orientaion_0.png" alt="Orientation"><br>使用Android的GLSurfaceView显示时，得出结论：<br>摄像头后置：摄像头ID “0”<br>Surface.ROTATION_0   画面需要逆时针旋转90度，同时调整GLSurfaceView的显示比例<br>Surface.ROTATION_90  画面方向无需处理<br>Surface.ROTATION_180 画面方向无需处理<br>Surface.ROTATION_270 湖面需要顺时针旋转180度，同时调整GLSurfaceView的显示比例</p><h3 id="Camera2打开相机"><a href="#Camera2打开相机" class="headerlink" title="Camera2打开相机"></a>Camera2打开相机</h3><pre><code>1.仅用来显示：获取当前显示屏幕的DisplayWidth,DisplayHeight(屏幕的宽高)2.仅用来显示：获取需要打开摄像头的Preview的Size属性(cameraCharacteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP)),获取其中最符合屏幕比例且分辨率大的PreViewSize3.通过CameraManager.OpenCamera()方法打开相机设置4.通过CaptureRequest.Builde设置相机的Target(可以设置多个)    例如：通过GLES生成OES纹理并绑定到SurfaceTexture上，通过并将SurfaceTexture设置宽高(1,2步骤获取)后，添加到Surface上，最后将Surface添加到 CaptureRequest.Builde.addTarget(surface);    例如：创建ImageReader，并将其Surface(getSurface()),添加到CaptureRequest.Builde.addTarget(surface);    结论：CaptureRequest.Builde.addTarget(Surface)方法的意义在于将目标Surface(提前设置宽高)传递给相机，相机生产方可以同时将不同分辨率的数据传递给不同消费者。    消费者：TextureView,GLSurfaceView,ImageReader等</code></pre><h3 id="显示相机画面"><a href="#显示相机画面" class="headerlink" title="显示相机画面"></a>显示相机画面</h3><pre><code>1.通过GLSurfaceView显示相机画面(绑定OES纹理，自定义GLSurfaceView.Renderer)即可，画面方向以及比例可以通过顶点坐标或者相机Matrix来进行调节2.通过TextureView显示相机画面，将TextureView.getSurfaceTexture()方法，设置target同理，可以对TextureView进行旋转，平移操作，保证画面比例正常</code></pre><h3 id="ImageReader创建"><a href="#ImageReader创建" class="headerlink" title="ImageReader创建"></a>ImageReader创建</h3><pre><code>1.ImageReader的可以用来获取相机的帧数据，通过对帧数据的处理，实现对象检测,人脸检测,等需要单帧处理的场景2.在很多官方例子中便可以看到，例如：    2.1 TFLite ObjectDetect 中将Image数据转成Bitmap然后传递给识别接口    2.2 OpenCV Face Detect中将Image数据转成Mat,然后将灰度Mat传递给识别接口    2.3 人脸识别以及landmark中通过将Image数据转换成为NV21类型，传递给识别接口3. 显示相机画面时部分Orientation进行旋转操作，同理ImageReader获取到的接口也需要进行处理，方可得到正确方向的数据。</code></pre><h3 id="ImageReader转码"><a href="#ImageReader转码" class="headerlink" title="ImageReader转码"></a>ImageReader转码</h3><ol><li>OpenCV转码(来源于OpenCV SDK官方实现 ImageFormat.YUV_420_888转Mat) <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Yuv4208882Mat</span> <span class="hljs-title">implements</span> <span class="hljs-title">CvCameraViewFrame</span> &#123;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Mat <span class="hljs-title">gray</span><span class="hljs-params">()</span> </span>&#123;<br>        Image.Plane[] planes = mImage.getPlanes();<br>        <span class="hljs-keyword">int</span> w = mImage.getWidth();<br>        <span class="hljs-keyword">int</span> h = mImage.getHeight();<br>        assert (planes[<span class="hljs-number">0</span>].getPixelStride() == <span class="hljs-number">1</span>);<br>        ByteBuffer y_plane = planes[<span class="hljs-number">0</span>].getBuffer();<br>        <span class="hljs-keyword">int</span> y_plane_step = planes[<span class="hljs-number">0</span>].getRowStride();<br>        mGray = <span class="hljs-keyword">new</span> Mat(h, w, CvType.CV_8UC1, y_plane, y_plane_step);<br>        <span class="hljs-keyword">return</span> mGray;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Mat <span class="hljs-title">rgba</span><span class="hljs-params">()</span> </span>&#123;<br>        Image.Plane[] planes = mImage.getPlanes();<br>        <span class="hljs-keyword">int</span> w = mImage.getWidth();<br>        <span class="hljs-keyword">int</span> h = mImage.getHeight();<br>        <span class="hljs-keyword">int</span> chromaPixelStride = planes[<span class="hljs-number">1</span>].getPixelStride();<br><br><br>        <span class="hljs-keyword">if</span> (chromaPixelStride == <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">// Chroma channels are interleaved</span><br>            assert (planes[<span class="hljs-number">0</span>].getPixelStride() == <span class="hljs-number">1</span>);<br>            assert (planes[<span class="hljs-number">2</span>].getPixelStride() == <span class="hljs-number">2</span>);<br>            ByteBuffer y_plane = planes[<span class="hljs-number">0</span>].getBuffer();<br>            <span class="hljs-keyword">int</span> y_plane_step = planes[<span class="hljs-number">0</span>].getRowStride();<br>            ByteBuffer uv_plane1 = planes[<span class="hljs-number">1</span>].getBuffer();<br>            <span class="hljs-keyword">int</span> uv_plane1_step = planes[<span class="hljs-number">1</span>].getRowStride();<br>            ByteBuffer uv_plane2 = planes[<span class="hljs-number">2</span>].getBuffer();<br>            <span class="hljs-keyword">int</span> uv_plane2_step = planes[<span class="hljs-number">2</span>].getRowStride();<br>            Mat y_mat = <span class="hljs-keyword">new</span> Mat(h, w, CvType.CV_8UC1, y_plane, y_plane_step);<br>            Mat uv_mat1 = <span class="hljs-keyword">new</span> Mat(h / <span class="hljs-number">2</span>, w / <span class="hljs-number">2</span>, CvType.CV_8UC2, uv_plane1, uv_plane1_step);<br>            Mat uv_mat2 = <span class="hljs-keyword">new</span> Mat(h / <span class="hljs-number">2</span>, w / <span class="hljs-number">2</span>, CvType.CV_8UC2, uv_plane2, uv_plane2_step);<br>            <span class="hljs-keyword">long</span> addr_diff = uv_mat2.dataAddr() - uv_mat1.dataAddr();<br>            <span class="hljs-keyword">if</span> (addr_diff &gt; <span class="hljs-number">0</span>) &#123;<br>                assert (addr_diff == <span class="hljs-number">1</span>);<br>                Imgproc.cvtColorTwoPlane(y_mat, uv_mat1, mRgba, Imgproc.COLOR_YUV2RGBA_NV12);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                assert (addr_diff == <span class="hljs-number">-1</span>);<br>                Imgproc.cvtColorTwoPlane(y_mat, uv_mat2, mRgba, Imgproc.COLOR_YUV2RGBA_NV21);<br>            &#125;<br>            <span class="hljs-keyword">return</span> mRgba;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// Chroma channels are not interleaved</span><br>            <span class="hljs-keyword">byte</span>[] yuv_bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[w * (h + h / <span class="hljs-number">2</span>)];<br>            ByteBuffer y_plane = planes[<span class="hljs-number">0</span>].getBuffer();<br>            ByteBuffer u_plane = planes[<span class="hljs-number">1</span>].getBuffer();<br>            ByteBuffer v_plane = planes[<span class="hljs-number">2</span>].getBuffer();<br><br>            <span class="hljs-keyword">int</span> yuv_bytes_offset = <span class="hljs-number">0</span>;<br><br>            <span class="hljs-keyword">int</span> y_plane_step = planes[<span class="hljs-number">0</span>].getRowStride();<br>            <span class="hljs-keyword">if</span> (y_plane_step == w) &#123;<br>                y_plane.<span class="hljs-built_in">get</span>(yuv_bytes, <span class="hljs-number">0</span>, w * h);<br>                yuv_bytes_offset = w * h;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">int</span> padding = y_plane_step - w;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; h; i++) &#123;<br>                    y_plane.<span class="hljs-built_in">get</span>(yuv_bytes, yuv_bytes_offset, w);<br>                    yuv_bytes_offset += w;<br>                    <span class="hljs-keyword">if</span> (i &lt; h - <span class="hljs-number">1</span>) &#123;<br>                        y_plane.<span class="hljs-built_in">position</span>(y_plane.<span class="hljs-built_in">position</span>() + padding);<br>                    &#125;<br>                &#125;<br>                assert (yuv_bytes_offset == w * h);<br>            &#125;<br><br>            <span class="hljs-keyword">int</span> chromaRowStride = planes[<span class="hljs-number">1</span>].getRowStride();<br>            <span class="hljs-keyword">int</span> chromaRowPadding = chromaRowStride - w / <span class="hljs-number">2</span>;<br><br>            <span class="hljs-keyword">if</span> (chromaRowPadding == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// When the row stride of the chroma channels equals their width, we can copy</span><br>                <span class="hljs-comment">// the entire channels in one go</span><br>                u_plane.<span class="hljs-built_in">get</span>(yuv_bytes, yuv_bytes_offset, w * h / <span class="hljs-number">4</span>);<br>                yuv_bytes_offset += w * h / <span class="hljs-number">4</span>;<br>                v_plane.<span class="hljs-built_in">get</span>(yuv_bytes, yuv_bytes_offset, w * h / <span class="hljs-number">4</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// When not equal, we need to copy the channels row by row</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; h / <span class="hljs-number">2</span>; i++) &#123;<br>                    u_plane.<span class="hljs-built_in">get</span>(yuv_bytes, yuv_bytes_offset, w / <span class="hljs-number">2</span>);<br>                    yuv_bytes_offset += w / <span class="hljs-number">2</span>;<br>                    <span class="hljs-keyword">if</span> (i &lt; h / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>) &#123;<br>                        u_plane.<span class="hljs-built_in">position</span>(u_plane.<span class="hljs-built_in">position</span>() + chromaRowPadding);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; h / <span class="hljs-number">2</span>; i++) &#123;<br>                    v_plane.<span class="hljs-built_in">get</span>(yuv_bytes, yuv_bytes_offset, w / <span class="hljs-number">2</span>);<br>                    yuv_bytes_offset += w / <span class="hljs-number">2</span>;<br>                    <span class="hljs-keyword">if</span> (i &lt; h / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>) &#123;<br>                        v_plane.<span class="hljs-built_in">position</span>(v_plane.<span class="hljs-built_in">position</span>() + chromaRowPadding);<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            Mat yuv_mat = <span class="hljs-keyword">new</span> Mat(h + h / <span class="hljs-number">2</span>, w, CvType.CV_8UC1);<br>            yuv_mat.<span class="hljs-built_in">put</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, yuv_bytes);<br>            Imgproc.cvtColor(yuv_mat, mRgba, Imgproc.COLOR_YUV2RGBA_I420, <span class="hljs-number">4</span>);<br>            <span class="hljs-keyword">return</span> mRgba;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Yuv4208882Mat</span><span class="hljs-params">(Image <span class="hljs-built_in">image</span>)</span> </span>&#123;<br>        super();<br>        mImage = <span class="hljs-built_in">image</span>;<br>        mRgba = <span class="hljs-keyword">new</span> Mat();<br>        mGray = <span class="hljs-keyword">new</span> Mat();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span> </span>&#123;<br>        mRgba.<span class="hljs-built_in">release</span>();<br>        mGray.<span class="hljs-built_in">release</span>();<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> Image mImage;<br>    <span class="hljs-keyword">private</span> Mat mRgba;<br>    <span class="hljs-keyword">private</span> Mat mGray;<br>&#125;    <br></code></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>例子TFLite Object Detector(ImageFormat.YUV_420_888转Bitmap)</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> saveBitmapFromBytes(Image image) &#123;<br>        Image.Plane[] planes = image.getPlanes();<br>        <span class="hljs-keyword">byte</span>[][] yuvBytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">3</span>][];<br>        fillBytes(planes, yuvBytes);<br>        <span class="hljs-keyword">int</span> yRowStride = planes[<span class="hljs-number">0</span>].getRowStride();<br>        <span class="hljs-keyword">int</span> uvRowStride = planes[<span class="hljs-number">1</span>].getRowStride();<br>        <span class="hljs-keyword">int</span> uvPixelStride = planes[<span class="hljs-number">1</span>].getPixelStride();<br>        ImageUtils.convertYUV420ToARGB8888(<br>                yuvBytes[<span class="hljs-number">0</span>],<br>                yuvBytes[<span class="hljs-number">1</span>],<br>                yuvBytes[<span class="hljs-number">2</span>],<br>                mPreviewSize.getWidth(),<br>                mPreviewSize.getHeight(),<br>                yRowStride,<br>                uvRowStride,<br>                uvPixelStride,<br>                rgbBytes);<br>        Bitmap rgbFrameBitmap = Bitmap.createBitmap(mPreviewSize.getWidth(), mPreviewSize.getHeight(), Bitmap.Config.ARGB_8888);<br>        rgbFrameBitmap.setPixels(rgbBytes, <span class="hljs-number">0</span>, mPreviewSize.getWidth(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, mPreviewSize.getWidth(), mPreviewSize.getHeight());<br>        <span class="hljs-keyword">File</span> <span class="hljs-keyword">file</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(activity.getExternalCacheDir() + <span class="hljs-string">&quot;/&quot;</span> + System.currentTimeMillis() + <span class="hljs-string">&quot;_compress.jpeg&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">file</span>.exists()) &#123;<br>            <span class="hljs-keyword">file</span>.getParentFile().mkdirs();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">file</span>.createNewFile();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>                Logger.e(TAG, <span class="hljs-string">&quot;[imageAvailableListenerDetect]&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            rgbFrameBitmap.compress(Bitmap.CompressFormat.JPEG, <span class="hljs-number">10</span>, <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">file</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br><br></code></pre></td></tr></table></figure></li><li><p>例子3 部分人脸识别(ImageFormat.YUV_420_888转NV21)</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">byte</span>[] getDataFromImage(Image <span class="hljs-built_in">image</span>, <span class="hljs-keyword">int</span> colorFormat) &#123;<br>    <span class="hljs-keyword">if</span> (colorFormat != COLOR_FormatI420 &amp;&amp; colorFormat != COLOR_FormatNV21) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;only support COLOR_FormatI420 &quot;</span> + <span class="hljs-string">&quot;and COLOR_FormatNV21&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!isImageFormatSupported(<span class="hljs-built_in">image</span>)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;can&#x27;t convert Image to byte array, format &quot;</span> + <span class="hljs-built_in">image</span>.getFormat());<br>    &#125;<br>    Rect crop = <span class="hljs-built_in">image</span>.getCropRect();<br>    <span class="hljs-keyword">int</span> format = <span class="hljs-built_in">image</span>.getFormat();<br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">width</span> = crop.<span class="hljs-built_in">width</span>();<br>    <span class="hljs-keyword">int</span> <span class="hljs-built_in">height</span> = crop.<span class="hljs-built_in">height</span>();<br>    Image.Plane[] planes = <span class="hljs-built_in">image</span>.getPlanes();<br>    <span class="hljs-keyword">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-built_in">width</span> * <span class="hljs-built_in">height</span> * ImageFormat.getBitsPerPixel(format) / <span class="hljs-number">8</span>];<br>    <span class="hljs-keyword">byte</span>[] rowData = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[planes[<span class="hljs-number">0</span>].getRowStride()];<br>    <span class="hljs-keyword">int</span> channelOffset = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> outputStride = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; planes.length; i++) &#123;<br>        <span class="hljs-keyword">switch</span> (i) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                channelOffset = <span class="hljs-number">0</span>;<br>                outputStride = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                <span class="hljs-keyword">if</span> (colorFormat == COLOR_FormatI420) &#123;<br>                    channelOffset = <span class="hljs-built_in">width</span> * <span class="hljs-built_in">height</span>;<br>                    outputStride = <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (colorFormat == COLOR_FormatNV21) &#123;<br>                    channelOffset = <span class="hljs-built_in">width</span> * <span class="hljs-built_in">height</span> + <span class="hljs-number">1</span>;<br>                    outputStride = <span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                <span class="hljs-keyword">if</span> (colorFormat == COLOR_FormatI420) &#123;<br>                    channelOffset = (<span class="hljs-keyword">int</span>) (<span class="hljs-built_in">width</span> * <span class="hljs-built_in">height</span> * <span class="hljs-number">1.25</span>);<br>                    outputStride = <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (colorFormat == COLOR_FormatNV21) &#123;<br>                    channelOffset = <span class="hljs-built_in">width</span> * <span class="hljs-built_in">height</span>;<br>                    outputStride = <span class="hljs-number">2</span>;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        ByteBuffer <span class="hljs-built_in">buffer</span> = planes[i].getBuffer();<br>        <span class="hljs-keyword">int</span> rowStride = planes[i].getRowStride();<br>        <span class="hljs-keyword">int</span> pixelStride = planes[i].getPixelStride();<br>        <span class="hljs-keyword">int</span> shift = (i == <span class="hljs-number">0</span>) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> w = <span class="hljs-built_in">width</span> &gt;&gt; shift;<br>        <span class="hljs-keyword">int</span> h = <span class="hljs-built_in">height</span> &gt;&gt; shift;<br>        <span class="hljs-built_in">buffer</span>.<span class="hljs-built_in">position</span>(rowStride * (crop.top &gt;&gt; shift) + pixelStride * (crop.left &gt;&gt; shift));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; h; row++) &#123;<br>            <span class="hljs-keyword">int</span> length;<br>            <span class="hljs-keyword">if</span> (pixelStride == <span class="hljs-number">1</span> &amp;&amp; outputStride == <span class="hljs-number">1</span>) &#123;<br>                length = w;<br>                <span class="hljs-built_in">buffer</span>.<span class="hljs-built_in">get</span>(data, channelOffset, length);<br>                channelOffset += length;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                length = (w - <span class="hljs-number">1</span>) * pixelStride + <span class="hljs-number">1</span>;<br>                <span class="hljs-built_in">buffer</span>.<span class="hljs-built_in">get</span>(rowData, <span class="hljs-number">0</span>, length);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; w; col++) &#123;<br>                    data[channelOffset] = rowData[col * pixelStride];<br>                    channelOffset += outputStride;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (row &lt; h - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-built_in">buffer</span>.<span class="hljs-built_in">position</span>(<span class="hljs-built_in">buffer</span>.<span class="hljs-built_in">position</span>() + rowStride - length);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> data;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>总结：Image的转码核心在于提取Y,U,V3个通道的数据后按照规定数据进行转换或者重新排列即可</p></li></ol><h3 id="参照例子"><a href="#参照例子" class="headerlink" title="参照例子"></a>参照例子</h3><ol><li>OpenCV Android SDK 4.5.2 (自行下载使用)</li><li><a href="https://github.com/tensorflow/examples/tree/master/lite/examples/object_detection/android">TFLite Object Detect</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念:&quot;&gt;&lt;/a&gt;基本概念:&lt;/h3&gt;&lt;h4 id=&quot;屏幕方向&quot;&gt;&lt;a href=&quot;#屏幕方向&quot; class=&quot;headerlink&quot; title=&quot;屏幕方向&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Android" scheme="http://example.com/categories/Android/"/>
    
    
    <category term="相机" scheme="http://example.com/tags/%E7%9B%B8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>java_String</title>
    <link href="http://example.com/2020/12/15/java/lang/String/"/>
    <id>http://example.com/2020/12/15/java/lang/String/</id>
    <published>2020-12-15T15:11:08.000Z</published>
    <updated>2022-01-04T13:26:28.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Char"><a href="#Char" class="headerlink" title="Char"></a>Char</h2><pre><code>1. String 底层实现为 char[]-----&gt;private final char value[]//char[] 数组2. String类为final类，也就是无法通过子类去继承。（final修饰的方法无法复写)</code></pre><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><pre><code>### 1. String 实现了接口列表    #### 1.1 java.io.Serialliable 序列化    #### 1.2 Comparable&lt;String&gt;----&gt;public int compareTo(String)  此接口用来设置排序的规则    #### 1.3 CharSequence### 2. String 内部实现    #### 2.1  private final char value[];//使用字符数组进行存储    #### 2.2  private int hash;//缓存字符串的哈希值### 3. String 方法    #### 3.1 String的构造方法中，涉及charset，使用到了StringCode类以及使用Arrays.copyof() 通过对char数组进行拷贝    </code></pre><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><pre><code>### 1. StringBuilder  A mutable sequence of characters.（可变序列序列），but with no guarantee of synchronization(但是无法保证同步)，used by a single thread,it will be faster under most implementation.### 2. StringBuilder 同样为final类，无法通过子类继承去修改实现,继承AbstractStringBuilder,       实现的接口列表                2.1 java.io.Serializable 序列化                2.2 CharSequence </code></pre><h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><pre><code>### 2. StringBuffer</code></pre><h2 id="延申知识"><a href="#延申知识" class="headerlink" title="延申知识"></a>延申知识</h2><pre><code>### 1. java.lang.Comparable的使用    o:specified object    return:    a negative integer  less than     zero                equal to    a positive integer  greater than     public int compareTo(T o);    查看String的源码发现实现此接口，String的比大小规则:两个字符串均从第一个字符起，比较字符的Unicode Value的大小    <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(<span class="hljs-keyword">String</span> anotherString)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len1 = value.length;<br>    <span class="hljs-keyword">int</span> len2 = anotherString.value.length;<br>    <span class="hljs-keyword">int</span> lim = Math.<span class="hljs-built_in">min</span>(len1, len2);<br>    <span class="hljs-keyword">char</span> v1[] = value;<br>    <span class="hljs-keyword">char</span> v2[] = anotherString.value;<br><br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (k &lt; lim) &#123;<br>        <span class="hljs-keyword">char</span> c1 = v1[k];<br>        <span class="hljs-keyword">char</span> c2 = v2[k];<br>        <span class="hljs-keyword">if</span> (c1 != c2) &#123;<br>            <span class="hljs-keyword">return</span> c1 - c2;<br>        &#125;<br>        k++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> len1 - len2;<br>&#125;<br></code></pre></td></tr></table></figure>### 2. 其他地方的使用    Lists (and arrays) of objects that implement this interface can be sorted automatically by Collection#sort(list) Collections.sort And Arrays.srot(Object[]) Arrays.sort.    这里提供集合对象的排序可以自动使用2个实现。    Collections.class    <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> Comparable&lt;? <span class="hljs-keyword">super</span> T&gt;&gt; <span class="hljs-keyword">void</span> <span class="hljs-keyword">sort</span>(List&lt;T&gt; list) &#123;<br>    list.<span class="hljs-keyword">sort</span>(<span class="hljs-keyword">null</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>    List.class    <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@SuppressWarnings</span>(&#123;<span class="hljs-string">&quot;unchecked&quot;</span>, <span class="hljs-string">&quot;rawtypes&quot;</span>&#125;)<br><span class="hljs-keyword">default</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">sort</span>(<span class="hljs-params">Comparator&lt;? <span class="hljs-built_in">super</span> E&gt; c</span>)</span> &#123;<br>    <span class="hljs-built_in">Object</span>[] a = <span class="hljs-built_in">this</span>.toArray();<br>    Arrays.sort(a, (Comparator) c);<br>    ListIterator&lt;E&gt; i = <span class="hljs-built_in">this</span>.listIterator();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">Object</span> e : a) &#123;<br>        i.next();<br>        i.set((E) e);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>    Arrays.class    ```        public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) &#123;            if (c == null) &#123;                sort(a);            &#125; else &#123;            if (LegacyMergeSort.userRequested)                legacyMergeSort(a, c);            else                TimSort.sort(a, 0, a.length, c, null, 0, 0);            &#125;        &#125;    ```     ### 3.CharSequence    3.1简介    &lt;tt&gt;CharSequence&lt;/tt&gt; is a readable sequence of &lt;code&gt;char&lt;/code&gt; values. This interface provides uniform, read-only access to many different kinds of &lt;code&gt;char&lt;/code&gt; sequences.     此接口提供对于char的可读序列，可以用来提供统一，仅读 对于各种各样的char序列(String,StringBuilder,StringBuffer)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Char&quot;&gt;&lt;a href=&quot;#Char&quot; class=&quot;headerlink&quot; title=&quot;Char&quot;&gt;&lt;/a&gt;Char&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1. String 底层实现为 char[]-----&amp;gt;private final char valu</summary>
      
    
    
    
    <category term="Java源码" scheme="http://example.com/categories/Java%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Java源码" scheme="http://example.com/tags/Java%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Java集合</title>
    <link href="http://example.com/2020/12/13/java/util/java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2020/12/13/java/util/java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3/</id>
    <published>2020-12-13T12:41:02.000Z</published>
    <updated>2021-01-05T14:14:04.857Z</updated>
    
    <content type="html"><![CDATA[<h2 id="源码类图"><a href="#源码类图" class="headerlink" title="源码类图"></a>源码类图</h2><p><img src="/images/java/Java_Util_Collections.png" alt="Java1.8"></p><h2 id="源码学习"><a href="#源码学习" class="headerlink" title="源码学习"></a>源码学习</h2><h3 id="1-List"><a href="#1-List" class="headerlink" title="1.List"></a>1.List</h3><h4 id="1-1-Vector"><a href="#1-1-Vector" class="headerlink" title="1.1 Vector"></a>1.1 Vector</h4><ul><li><p><a href="https://github.com/wupeixuan/JDKSourceCode1.8/blob/master/src/java/util/Vector.java">在线查看</a></p></li><li><p>Vector实现是数组，默认空构造方法长度为10，也可以根据传入initialCapacity</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Vector</span>(<span class="hljs-params">int initialCapacity, int capacityIncrement</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>();<br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+initialCapacity);<br>    <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>[initialCapacity];<br>    <span class="hljs-built_in">this</span>.capacityIncrement = capacityIncrement;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Vector</span>(<span class="hljs-params">int initialCapacity</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>(initialCapacity, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Vector</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>(<span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Vector使用时</p><ul><li><p>允许添加value是null</p></li><li><p>size(),isEmpty(),get(index),set(int,E),add() 方法的执行时间复杂度O(1),注意这里的关键字Synchronized</p>  <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> elementCount;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> elementCount == <span class="hljs-number">0</span>;<br>&#125;    <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (index &gt;= elementCount)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArrayIndexOutOfBoundsException(index);<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">elementData</span><span class="hljs-params">(index)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">E <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (index &gt;= elementCount)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArrayIndexOutOfBoundsException(index);<br>    E oldValue = elementData(index);<br>    elementData[index] = element;<br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125; <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    modCount++;<br>    ensureCapacityHelper(elementCount + <span class="hljs-number">1</span>);<br>    elementData[elementCount++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>线程是否安全？ 肯定的哈，这么多synchronized</p></li><li><p>扩容:看到这里发现了个”+”,原来是2倍</p>   <figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haxe">grow(minCapacity);<br><span class="hljs-keyword">private</span> void grow(int minCapacity) &#123;<br>    int oldCapacity = elementData.length;<br>    int <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = oldCapacity + ((capacityIncrement &gt; <span class="hljs-number">0</span>) ?<br>                                 capacityIncrement : <span class="hljs-type">oldCapacity</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> - minCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = minCapacity;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = hugeCapacity(minCapacity);<br>    elementData = Arrays.copyOf(elementData, <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>扩容本质:</p>  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">Of(<span class="hljs-params">elementData</span>, <span class="hljs-params">newCapacity</span>)</span><br></code></pre></td></tr></table></figure></li><li><p>Vector看起来平常很少用哈！！！        </p></li></ul></li></ul><h4 id="1-2-ArrayList"><a href="#1-2-ArrayList" class="headerlink" title="1.2 ArrayList"></a>1.2 ArrayList</h4><ul><li><ul><li><a href="https://github.com/wupeixuan/JDKSourceCode1.8/blob/master/src/java/util/ArrayList.java">在线查看</a></li></ul></li><li><p>ArrayList实现是一个数组，默认长度10，size（int）表示长度。代码摘选如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACTITY=<span class="hljs-number">10</span>;<span class="hljs-comment">//默认长度</span><br><span class="hljs-keyword">transient</span> Object[] elementData;<span class="hljs-comment">//基本实现数组</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<span class="hljs-comment">//大小</span><br></code></pre></td></tr></table></figure></li><li><p>ArrayList 使用时</p><ul><li>允许添加value是null的值</li><li>size(),isEmpty(),get(index),set(),add()方法的执行时间复杂度均为O(1),这里的时间复杂度表示访问单个元素时，因为访问只需要一条指令。  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br><span class="hljs-comment">//返回List的大小实现</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">size</span>;<br>&#125;<br><br><span class="hljs-comment">//返回List是否为空</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">size</span> == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//根据index返回value</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    rangeCheck(index); <span class="hljs-comment">// 检查是否越界</span><br>    <span class="hljs-keyword">return</span> elementData(index);<span class="hljs-comment">// 返回ArrayList的elementData数组index位置的元素</span><br>&#125;<br><br><span class="hljs-comment">//设置index的value</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;<br>    rangeCheck(index); <span class="hljs-comment">// 检查是否越界</span><br>    E oldValue = elementData(index);<span class="hljs-comment">// 调用elementData(index)获取到当前位置的</span><br>    elementData[index] = element; <span class="hljs-comment">// 将element赋值到ArrayList的elementData数组的第index位置</span><br>   <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br><br><span class="hljs-comment">//添加一个值(在添加时未进行null判断，所有ArrayLsit是允许空值存在)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    ensureCapacityInternal(<span class="hljs-built_in">size</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// 扩容 // Increments modCount!!</span><br>    elementData[<span class="hljs-built_in">size</span>++] = e;   <span class="hljs-comment">// 将e赋值给elementData的size+1的位置</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;   <br></code></pre></td></tr></table></figure></li></ul></li><li><p>线程是否安全？ 不安全，这里并未看到对方法或者全局变量使用synchronized关键字。以及size并未使用volatile修饰</p></li></ul><ul><li>扩容规则<ul><li>扩容大小为原大小的1.5倍,后使用Arrays.copyof(old,new)  <figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">private</span> void grow(int minCapacity) &#123;<br>    int oldCapacity = elementData.length; <span class="hljs-comment">// 获取到ArrayList中elementData数组的内存空间长度</span><br>    int <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<span class="hljs-comment">// 扩容至原来的1.5倍</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> - minCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = minCapacity;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">//若预设值大于默认的最大值检查是否溢出</span><br>        <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = hugeCapacity(minCapacity);<br>    elementData = Arrays.copyOf(elementData, <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span>);<span class="hljs-comment">// 并将elementData的数据复制到新的内存空间</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>扩容的本质：  <figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">System.arraycopy(elementData, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span><span class="hljs-type">ElementData</span>, <span class="hljs-number">0</span>,Math.min(elementData.length,<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span>))<br></code></pre></td></tr></table></figure></li></ul></li><li>使用总结<ul><li>ArrayList删除时间复杂度为O(1),且允许删除null值</li><li>ArrayList全局变量且多线程使用时，存在问题.作为局部变量，放心用吧！！！</li><li>可以使用的Collections#synchronizedList保证线程安全</li><li>使用ArrayList时为了便面多次copy的过程,可以在初始化时指定固定大小</li></ul></li></ul><h4 id="1-2-LinkedList"><a href="#1-2-LinkedList" class="headerlink" title="1.2 LinkedList"></a>1.2 LinkedList<E></h4><ul><li><p><a href="https://github.com/wupeixuan/JDKSourceCode1.8/blob/master/src/java/util/LinkedList.java">在线查看</a></p></li><li><p>LinkedList底层数据结构是一个双向链表，既然是双向链表。可以被当作栈，队列。非线程安全</p>  <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">transient int <span class="hljs-attr">size=</span><span class="hljs-number">0</span>;<br>transient <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;E</span>&gt; first;//transient 防止序列化<br>transient <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;E</span>&gt; last;<br></code></pre></td></tr></table></figure></li><li><p>LinkedList 方法实现(这里只对思路和public方法记录下)</p><ul><li>头节点插入  <figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">private</span> void linkFirst(E e)&#123;<br>    final Node&lt;E&gt; f = first;<br>    final Node&lt;E&gt; <span class="hljs-keyword">new</span><span class="hljs-type">Node</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">Node</span>&lt;&gt;(<span class="hljs-literal">null</span>,e,f);<br>    first = <span class="hljs-keyword">new</span><span class="hljs-type">Node</span>;<br>    <span class="hljs-keyword">if</span>(f == <span class="hljs-literal">null</span>)<br>        last = <span class="hljs-keyword">new</span><span class="hljs-type">Node</span>;<br>    <span class="hljs-keyword">else</span><br>        f.prev = <span class="hljs-keyword">new</span><span class="hljs-type">Node</span>;<br>    size++;<br>    modCount++;    <br>&#125;<br></code></pre></td></tr></table></figure></li><li>尾节点插入(不做笔记)</li><li>在succ节点前插入  <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">void linkBefore(E e,<span class="hljs-keyword">Node</span><span class="hljs-title">&lt;E</span>&gt; succ)&#123;<br>    final <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;E</span>&gt; pred = succ.prev;//保存前一个节点<br>    final <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;E</span>&gt; newNode = new <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;&gt;(pred</span>,e,succ);//创建一个新的节点<br>    succ.prev = newNode;//succ的前节点设置为newNode<br>    if(<span class="hljs-attr">pred=</span>=null)<br>        first = newNode;<br>    else<br>        pred.next = newNode;<br>    size++;<br>    modCount++;        <br>&#125;<br></code></pre></td></tr></table></figure></li><li>删除非空节点</li><li>获取首节点,并且返回头节点值  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> E <span class="hljs-function"><span class="hljs-title">getFirst</span>(<span class="hljs-params"></span>)</span>&#123;<br>    final Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">if</span>(f==<span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>    <span class="hljs-keyword">return</span> f.item    <br>&#125;<br></code></pre></td></tr></table></figure></li><li>获取尾节点，返回存储的元素值</li><li>在头节点插入</li><li>判断元素是否包含  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript">        <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">contains</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> o</span>)</span>&#123;<br>            <span class="hljs-keyword">return</span> indexOf(o)!=-<span class="hljs-number">1</span>;<br>        &#125;<br>    <span class="hljs-string">``</span><span class="hljs-string">` </span><br><span class="hljs-string">- 查询操作返回对应的Index</span><br></code></pre></td></tr></table></figure><pre><code>  public int indexOf(Object o)&#123;      int index = 0;      if(o==null)&#123;          for(Node&lt;E&gt; x= first;x!=null;x=x.next)&#123;              if(x.itme==null)                  return index;              index++;              &#125;      &#125;else&#123;          for(Node&lt;E&gt; x= first;x!=null;x=x.next)&#123;              if(o.equals(x.item))                  return index;              index++;              &#125;              &#125;  &#125;</code></pre>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">    - 获取头节点 peeK()<br>    - 获取并删除头节点 poll()<br>    - 等等（这些方法的实现还是比较简单，都是比较常规的操作)<br><span class="hljs-comment">### 2.Map</span><br><span class="hljs-comment">#### 2.1 HashMap</span><br>- [在线查看](https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/wupeixuan/</span>JDKSourceCode1.<span class="hljs-number">8</span><span class="hljs-regexp">/blob/m</span>aster<span class="hljs-regexp">/src/</span>java<span class="hljs-regexp">/util/</span>HashMap.java)<br>- HashMap底层数据结构<br><br>    数组+链表+红黑树，当链表的长度大于等于<span class="hljs-number">8</span>时，链表会转换成为红黑树，当红黑树的大小小于等于<span class="hljs-number">6</span>时，红黑树会转换成为链表。<br></code></pre></td></tr></table></figure>  static final int DEFAULT_ININIAL_CAPCITY=1&lt;&lt;4;//默认16<br>  static final int MAXIMUM_CAPACITY =1&lt;&lt;30;//最大<br>  transient Node&lt;K,V&gt;[] table;//存储数组的元素<br>  static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt;{}//红黑树的实现<br>  static class Node&lt;K, V&gt; implements Map.Entry&lt;K, V&gt;{}//链表的节点<br>```</li></ul></li><li></li></ul><h5 id="2-1-1-LinkedHashMap"><a href="#2-1-1-LinkedHashMap" class="headerlink" title="2.1.1 LinkedHashMap"></a>2.1.1 LinkedHashMap</h5><h4 id="2-2-TreeMap"><a href="#2-2-TreeMap" class="headerlink" title="2.2 TreeMap"></a>2.2 TreeMap</h4><h4 id="2-3-HashTable"><a href="#2-3-HashTable" class="headerlink" title="2.3 HashTable"></a>2.3 HashTable</h4><h4 id="2-4-EnumMap"><a href="#2-4-EnumMap" class="headerlink" title="2.4 EnumMap"></a>2.4 EnumMap</h4><h3 id="3-Set"><a href="#3-Set" class="headerlink" title="3.Set"></a>3.Set</h3><h4 id="3-1-HashSet"><a href="#3-1-HashSet" class="headerlink" title="3.1 HashSet"></a>3.1 HashSet</h4><h4 id="3-1-1-LinkedHashSet"><a href="#3-1-1-LinkedHashSet" class="headerlink" title="3.1.1 LinkedHashSet"></a>3.1.1 LinkedHashSet</h4><h4 id="3-2-TreeSet"><a href="#3-2-TreeSet" class="headerlink" title="3.2 TreeSet"></a>3.2 TreeSet</h4><h4 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;源码类图&quot;&gt;&lt;a href=&quot;#源码类图&quot; class=&quot;headerlink&quot; title=&quot;源码类图&quot;&gt;&lt;/a&gt;源码类图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/java/Java_Util_Collections.png&quot; alt=&quot;Java1.8</summary>
      
    
    
    
    <category term="Java源码" scheme="http://example.com/categories/Java%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="Java源码" scheme="http://example.com/tags/Java%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github+fluid搭建</title>
    <link href="http://example.com/2020/12/12/my-site/"/>
    <id>http://example.com/2020/12/12/my-site/</id>
    <published>2020-12-12T11:10:53.000Z</published>
    <updated>2021-09-14T14:17:57.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hexo-Github-fluid搭建记录"><a href="#Hexo-Github-fluid搭建记录" class="headerlink" title="Hexo+Github+fluid搭建记录"></a>Hexo+Github+fluid搭建记录</h2><h4 id="主体流程"><a href="#主体流程" class="headerlink" title="主体流程"></a>主体流程</h4><p>1.Github 注册账号,创建”*.github.io”的仓库<br>2.安装Node.js后,使用npm install hexo<br>3.修改默认theme为fluid</p><h3 id="需要参考的链接"><a href="#需要参考的链接" class="headerlink" title="需要参考的链接"></a>需要参考的链接</h3><p><a href="https://github.com/">Github</a><br><a href="https://nodejs.org/">Node.js</a><br><a href="https://hexo.io/zh-cn/">Hexo</a><br><a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a></p><h2 id="创建博客的原因"><a href="#创建博客的原因" class="headerlink" title="创建博客的原因"></a>创建博客的原因</h2><ol><li><p>一名Android开发</p><ol><li>日常记录<br>以上这些模块曾经已经整理详细学习记录（软件&amp;硬件知识)，希望在后续维护中，补充上来！！！</li></ol></li><li><p>其他知识模块如下</p><p> 2.1 Android Camera(相机应用)<br> 2.2 Android OpenGLES(图像处理)<br> 2.3 Android AI(TFLite)</p></li><li><p>学习方向<br> 3.1 美颜算法了解和学习<br> 3.2 算法题</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Hexo-Github-fluid搭建记录&quot;&gt;&lt;a href=&quot;#Hexo-Github-fluid搭建记录&quot; class=&quot;headerlink&quot; title=&quot;Hexo+Github+fluid搭建记录&quot;&gt;&lt;/a&gt;Hexo+Github+fluid搭建记录&lt;/</summary>
      
    
    
    
    <category term="其他" scheme="http://example.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="工具使用记录" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2020/12/12/hello-world/"/>
    <id>http://example.com/2020/12/12/hello-world/</id>
    <published>2020-12-12T11:04:53.223Z</published>
    <updated>2020-12-12T11:04:53.223Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
