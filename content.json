{"meta":{"title":"学习/分享/记录","subtitle":"","description":"个人小站点","author":"张xiao博","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"Android/OpenGLES/Tmp","date":"2021-12-31T03:36:12.149Z","updated":"2022-01-02T01:33:47.726Z","comments":true,"path":"2021/12/31/Android/OpenGLES/Tmp/","link":"","permalink":"http://example.com/2021/12/31/Android/OpenGLES/Tmp/","excerpt":"","text":"precision mediump float; varying vec2 aCoord; uniform sampler2D vTexture; uniform vec2 left_eye;//左眼uniform vec2 right_eye;//右眼 float fs(float r, float rmax){ float a = 0.6; return (1.0 - pow((r / rmax - 1.0), 2.0) * a);}//coord:输入采样点 eye:眼睛坐标点 rmax:最大作用半径//这个方法的目的是重新返回一个采样点的坐标，来实现放大效果vec2 newCoord(vec2 coord, vec2 eye, float rmax){ vec2 new_coord = coord; //1 算出当前采样点的坐标与眼睛的距离 float r = distance(coord, eye); //如果在作用半径范围内 if(r &lt; rmax)&#123; //2 套用放大公式 即根据 当前采样点与眼睛的距离 和 作用半径 算出一个系数 float fsr = fs(r, rmax); //3 用这个系数来求得新坐标点的位置 new_coord - eye = fsr*(coord - eye) new_coord = fsr * (coord - eye) + eye; &#125; return new_coord; } void main() { //1 计算放大半径 float rmax = distance(left_eye, right_eye) / 2.0; //2.1 计算左眼放大处理后的采样点坐标 vec2 new_coord = newCoord(aCoord, left_eye, rmax); //2.2 计算右眼放大处理后的采样点坐标 new_coord = newCoord(new_coord, right_eye, rmax); //3 将重新求得的采样点坐标传给片元着色器 gl_FragColor = texture2D(vTexture, new_coord); }","categories":[],"tags":[]},{"title":"OpenGLES FBO 学习","slug":"Android/OpenGLES/OpenGLES_FBO","date":"2021-12-27T01:11:02.000Z","updated":"2022-01-06T12:16:51.045Z","comments":true,"path":"2021/12/27/Android/OpenGLES/OpenGLES_FBO/","link":"","permalink":"http://example.com/2021/12/27/Android/OpenGLES/OpenGLES_FBO/","excerpt":"","text":"基本知识 1. Android系统默认渲染器 OpenGL,系统启动时，经过BootLoader启动，kernel启动----&gt;init进程启动核心进程（ServiceManager,zygote,OpenGL)----&gt;播放开机动画 OpenGL渲染管线的最后一个阶段就是帧缓冲区（FrameBuffer) 2. OpenGL渲染管线的最后阶段FrameBuffer,Android系统存在默认缓冲区（window-system-provided frame),用于屏幕显示。GPU往显示缓冲区写入数据时，屏幕会显示缓冲内容。 使用FBO可以让数据不渲染到屏幕上，渲染到离屏的Buffer中 Android中后台给视频添加水印，Camera实时滤镜，需要把原数据经过处理后保存但是不显示数据 3.对于默认的相机，使用系统提供的OpenGL渲染的帧缓冲区（OES），OpenGL所有渲染结果直接到达帧缓冲区----&gt;on-Srceen渲染方式 对于贴纸相机，使用帧缓冲区对象，OpenGL将提供给窗口的帧缓冲区重定向FBO之中 4. FBO提供缓冲区：颜色缓冲区，深度缓冲区，模板缓冲区 FBO提供2种绑定的对象：纹理图片(texture images) 和 渲染图像(renderbuffer images) 4.1 纹理绑定FBO,OpenGL执行渲染到纹理操作 4.2 渲染绑定FBO，OpenGL执行离屏渲染 4.3 通过GL_MAX_COLOR_ATTACHMENTS查询颜色缓冲区挂节点 4.4 纹理对象 glFramebufferTexture2D 渲染对象 glFramebufferRenderbuffer 5. FBO (Frame Buffer Object) 帧缓冲区对象，FBO本身不能用于渲染，只有添加了纹理或者渲染缓冲区后才能作为渲染目标 6. FBO 使用流程图 使用#### 1.使用FBO处理图片滤镜 ### 2.使用FBO处理相机纹理","categories":[{"name":"OpenGLES","slug":"OpenGLES","permalink":"http://example.com/categories/OpenGLES/"}],"tags":[{"name":"OpenGLES","slug":"OpenGLES","permalink":"http://example.com/tags/OpenGLES/"}]},{"title":"java_String","slug":"java/lang/String","date":"2020-12-15T15:11:08.000Z","updated":"2022-01-04T13:26:28.906Z","comments":true,"path":"2020/12/15/java/lang/String/","link":"","permalink":"http://example.com/2020/12/15/java/lang/String/","excerpt":"","text":"Char1. String 底层实现为 char[]-----&gt;private final char value[]//char[] 数组 2. String类为final类，也就是无法通过子类去继承。（final修饰的方法无法复写) String### 1. String 实现了接口列表 #### 1.1 java.io.Serialliable 序列化 #### 1.2 Comparable&lt;String&gt;----&gt;public int compareTo(String) 此接口用来设置排序的规则 #### 1.3 CharSequence ### 2. String 内部实现 #### 2.1 private final char value[];//使用字符数组进行存储 #### 2.2 private int hash;//缓存字符串的哈希值 ### 3. String 方法 #### 3.1 String的构造方法中，涉及charset，使用到了StringCode类以及使用Arrays.copyof() 通过对char数组进行拷贝 StringBuilder### 1. StringBuilder A mutable sequence of characters.（可变序列序列），but with no guarantee of synchronization(但是无法保证同步)，used by a single thread,it will be faster under most implementation. ### 2. StringBuilder 同样为final类，无法通过子类继承去修改实现,继承AbstractStringBuilder, 实现的接口列表 2.1 java.io.Serializable 序列化 2.2 CharSequence StringBuffer### 2. StringBuffer 延申知识### 1. java.lang.Comparable的使用 o:specified object return: a negative integer less than zero equal to a positive integer greater than public int compareTo(T o); 查看String的源码发现实现此接口，String的比大小规则:两个字符串均从第一个字符起，比较字符的Unicode Value的大小 123456789101112131415161718public int compareTo(String anotherString) &#123; int len1 = value.length; int len2 = anotherString.value.length; int lim = Math.min(len1, len2); char v1[] = value; char v2[] = anotherString.value; int k = 0; while (k &lt; lim) &#123; char c1 = v1[k]; char c2 = v2[k]; if (c1 != c2) &#123; return c1 - c2; &#125; k++; &#125; return len1 - len2;&#125; ### 2. 其他地方的使用 Lists (and arrays) of objects that implement this interface can be sorted automatically by Collection#sort(list) Collections.sort And Arrays.srot(Object[]) Arrays.sort. 这里提供集合对象的排序可以自动使用2个实现。 Collections.class 1234public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) &#123; list.sort(null);&#125; List.class 1234567891011@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)default void sort(Comparator&lt;? super E&gt; c) &#123; Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c); ListIterator&lt;E&gt; i = this.listIterator(); for (Object e : a) &#123; i.next(); i.set((E) e); &#125;&#125; Arrays.class ``` public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) &#123; if (c == null) &#123; sort(a); &#125; else &#123; if (LegacyMergeSort.userRequested) legacyMergeSort(a, c); else TimSort.sort(a, 0, a.length, c, null, 0, 0); &#125; &#125; ``` ### 3.CharSequence 3.1简介 &lt;tt&gt;CharSequence&lt;/tt&gt; is a readable sequence of &lt;code&gt;char&lt;/code&gt; values. This interface provides uniform, read-only access to many different kinds of &lt;code&gt;char&lt;/code&gt; sequences. 此接口提供对于char的可读序列，可以用来提供统一，仅读 对于各种各样的char序列(String,StringBuilder,StringBuffer)","categories":[{"name":"Java源码","slug":"Java源码","permalink":"http://example.com/categories/Java%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"Java源码","slug":"Java源码","permalink":"http://example.com/tags/Java%E6%BA%90%E7%A0%81/"}]},{"title":"Camera2+GLSurfaceView使用","slug":"Android/Camera2/Camera2_GlSurfaceView","date":"2020-12-13T12:41:02.000Z","updated":"2022-01-07T01:39:27.188Z","comments":true,"path":"2020/12/13/Android/Camera2/Camera2_GlSurfaceView/","link":"","permalink":"http://example.com/2020/12/13/Android/Camera2/Camera2_GlSurfaceView/","excerpt":"","text":"基本概念: 打开相机显示相机使用ImageReaderImage转码","categories":[{"name":"Android","slug":"Android","permalink":"http://example.com/categories/Android/"}],"tags":[{"name":"相机","slug":"相机","permalink":"http://example.com/tags/%E7%9B%B8%E6%9C%BA/"}]},{"title":"Java集合","slug":"java/util/java集合相关","date":"2020-12-13T12:41:02.000Z","updated":"2021-01-05T14:14:04.857Z","comments":true,"path":"2020/12/13/java/util/java集合相关/","link":"","permalink":"http://example.com/2020/12/13/java/util/java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3/","excerpt":"","text":"源码类图 源码学习1.List1.1 Vector 在线查看 Vector实现是数组，默认空构造方法长度为10，也可以根据传入initialCapacity 12345678910111213public Vector(int initialCapacity, int capacityIncrement) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+initialCapacity); this.elementData = new Object[initialCapacity]; this.capacityIncrement = capacityIncrement;&#125;public Vector(int initialCapacity) &#123; this(initialCapacity, 0);&#125;public Vector() &#123; this(10);&#125; Vector使用时 允许添加value是null size(),isEmpty(),get(index),set(int,E),add() 方法的执行时间复杂度O(1),注意这里的关键字Synchronized 1234567891011121314151617181920212223242526272829public synchronized int size() &#123; return elementCount;&#125;public synchronized boolean isEmpty() &#123; return elementCount == 0;&#125; public synchronized E get(int index) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); return elementData(index);&#125;public synchronized E set(int index, E element) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true;&#125; 线程是否安全？ 肯定的哈，这么多synchronized 扩容:看到这里发现了个”+”,原来是2倍 1234567891011grow(minCapacity);private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity);&#125; 扩容本质: 1Arrays.copyOf(elementData, newCapacity) Vector看起来平常很少用哈！！！ 1.2 ArrayList 在线查看 ArrayList实现是一个数组，默认长度10，size（int）表示长度。代码摘选如下： 123private static final int DEFAULT_CAPACTITY=10;//默认长度transient Object[] elementData;//基本实现数组private int size;//大小 ArrayList 使用时 允许添加value是null的值 size(),isEmpty(),get(index),set(),add()方法的执行时间复杂度均为O(1),这里的时间复杂度表示访问单个元素时，因为访问只需要一条指令。 12345678910111213141516171819202122232425262728293031//返回List的大小实现public int size() &#123;return size;&#125;//返回List是否为空public boolean isEmpty() &#123; return size == 0;&#125;//根据index返回valuepublic E get(int index) &#123; rangeCheck(index); // 检查是否越界 return elementData(index);// 返回ArrayList的elementData数组index位置的元素&#125;//设置index的valuepublic E set(int index, E element) &#123; rangeCheck(index); // 检查是否越界 E oldValue = elementData(index);// 调用elementData(index)获取到当前位置的 elementData[index] = element; // 将element赋值到ArrayList的elementData数组的第index位置 return oldValue;&#125;//添加一个值(在添加时未进行null判断，所有ArrayLsit是允许空值存在)public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // 扩容 // Increments modCount!! elementData[size++] = e; // 将e赋值给elementData的size+1的位置 return true;&#125; 线程是否安全？ 不安全，这里并未看到对方法或者全局变量使用synchronized关键字。以及size并未使用volatile修饰 扩容规则 扩容大小为原大小的1.5倍,后使用Arrays.copyof(old,new) 123456789private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; // 获取到ArrayList中elementData数组的内存空间长度 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);// 扩容至原来的1.5倍 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0)//若预设值大于默认的最大值检查是否溢出 newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity);// 并将elementData的数据复制到新的内存空间&#125; 扩容的本质： 1System.arraycopy(elementData, 0, newElementData, 0,Math.min(elementData.length,newCapacity)) 使用总结 ArrayList删除时间复杂度为O(1),且允许删除null值 ArrayList全局变量且多线程使用时，存在问题.作为局部变量，放心用吧！！！ 可以使用的Collections#synchronizedList保证线程安全 使用ArrayList时为了便面多次copy的过程,可以在初始化时指定固定大小 1.2 LinkedList 在线查看 LinkedList底层数据结构是一个双向链表，既然是双向链表。可以被当作栈，队列。非线程安全 123transient int size=0;transient Node&lt;E&gt; first;//transient 防止序列化transient Node&lt;E&gt; last; LinkedList 方法实现(这里只对思路和public方法记录下) 头节点插入 1234567891011private void linkFirst(E e)&#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null,e,f); first = newNode; if(f == null) last = newNode; else f.prev = newNode; size++; modCount++; &#125; 尾节点插入(不做笔记) 在succ节点前插入 1234567891011void linkBefore(E e,Node&lt;E&gt; succ)&#123; final Node&lt;E&gt; pred = succ.prev;//保存前一个节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred,e,succ);//创建一个新的节点 succ.prev = newNode;//succ的前节点设置为newNode if(pred==null) first = newNode; else pred.next = newNode; size++; modCount++; &#125; 删除非空节点 获取首节点,并且返回头节点值 123456public E getFirst()&#123; final Node&lt;E&gt; f = first; if(f==null) throw new NoSuchElementException(); return f.item &#125; 获取尾节点，返回存储的元素值 在头节点插入 判断元素是否包含 12345 public boolean contains(Object o)&#123; return indexOf(o)!=-1; &#125; ``` - 查询操作返回对应的Index public int indexOf(Object o)&#123; int index = 0; if(o==null)&#123; for(Node&lt;E&gt; x= first;x!=null;x=x.next)&#123; if(x.itme==null) return index; index++; &#125; &#125;else&#123; for(Node&lt;E&gt; x= first;x!=null;x=x.next)&#123; if(o.equals(x.item)) return index; index++; &#125; &#125; &#125; 123456789 - 获取头节点 peeK() - 获取并删除头节点 poll() - 等等（这些方法的实现还是比较简单，都是比较常规的操作)### 2.Map#### 2.1 HashMap- [在线查看](https://github.com/wupeixuan/JDKSourceCode1.8/blob/master/src/java/util/HashMap.java)- HashMap底层数据结构 数组+链表+红黑树，当链表的长度大于等于8时，链表会转换成为红黑树，当红黑树的大小小于等于6时，红黑树会转换成为链表。 static final int DEFAULT_ININIAL_CAPCITY=1&lt;&lt;4;//默认16 static final int MAXIMUM_CAPACITY =1&lt;&lt;30;//最大 transient Node&lt;K,V&gt;[] table;//存储数组的元素 static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt;{}//红黑树的实现 static class Node&lt;K, V&gt; implements Map.Entry&lt;K, V&gt;{}//链表的节点``` 2.1.1 LinkedHashMap2.2 TreeMap2.3 HashTable2.4 EnumMap3.Set3.1 HashSet3.1.1 LinkedHashSet3.2 TreeSetSortedSet","categories":[{"name":"Java源码","slug":"Java源码","permalink":"http://example.com/categories/Java%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"Java源码","slug":"Java源码","permalink":"http://example.com/tags/Java%E6%BA%90%E7%A0%81/"}]},{"title":"Hexo+Github+fluid搭建","slug":"my-site","date":"2020-12-12T11:10:53.000Z","updated":"2021-09-14T14:17:57.478Z","comments":true,"path":"2020/12/12/my-site/","link":"","permalink":"http://example.com/2020/12/12/my-site/","excerpt":"","text":"Hexo+Github+fluid搭建记录主体流程1.Github 注册账号,创建”*.github.io”的仓库2.安装Node.js后,使用npm install hexo3.修改默认theme为fluid 需要参考的链接GithubNode.jsHexoFluid 创建博客的原因 一名Android开发 日常记录以上这些模块曾经已经整理详细学习记录（软件&amp;硬件知识)，希望在后续维护中，补充上来！！！ 其他知识模块如下 2.1 Android Camera(相机应用) 2.2 Android OpenGLES(图像处理) 2.3 Android AI(TFLite) 学习方向 3.1 美颜算法了解和学习 3.2 算法题","categories":[{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"工具使用记录","slug":"工具使用记录","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-12-12T11:04:53.223Z","updated":"2020-12-12T11:04:53.223Z","comments":true,"path":"2020/12/12/hello-world/","link":"","permalink":"http://example.com/2020/12/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"OpenGLES","slug":"OpenGLES","permalink":"http://example.com/categories/OpenGLES/"},{"name":"Java源码","slug":"Java源码","permalink":"http://example.com/categories/Java%E6%BA%90%E7%A0%81/"},{"name":"Android","slug":"Android","permalink":"http://example.com/categories/Android/"},{"name":"其他","slug":"其他","permalink":"http://example.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"OpenGLES","slug":"OpenGLES","permalink":"http://example.com/tags/OpenGLES/"},{"name":"Java源码","slug":"Java源码","permalink":"http://example.com/tags/Java%E6%BA%90%E7%A0%81/"},{"name":"相机","slug":"相机","permalink":"http://example.com/tags/%E7%9B%B8%E6%9C%BA/"},{"name":"工具使用记录","slug":"工具使用记录","permalink":"http://example.com/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"}]}