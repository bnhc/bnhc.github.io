<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>FaceDetector</title>
    <link href="/2022/01/07/OpenCV/FaceDetector/"/>
    <url>/2022/01/07/OpenCV/FaceDetector/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>OpenGLES_FBO</title>
    <link href="/2022/01/07/Android/OpelGLES/OpenGLES_FBO/"/>
    <url>/2022/01/07/Android/OpelGLES/OpenGLES_FBO/</url>
    
    <content type="html"><![CDATA[<h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><pre><code> 1. Android系统默认渲染器 OpenGL,系统启动时，经过BootLoader启动，kernel启动----&gt;init进程启动核心进程（ServiceManager,zygote,OpenGL)----&gt;播放开机动画        OpenGL渲染管线的最后一个阶段就是帧缓冲区（FrameBuffer) 2. OpenGL渲染管线的最后阶段FrameBuffer,Android系统存在默认缓冲区（window-system-provided frame),用于屏幕显示。GPU往显示缓冲区写入数据时，屏幕会显示缓冲内容。        使用FBO可以让数据不渲染到屏幕上，渲染到离屏的Buffer中        Android中后台给视频添加水印，Camera实时滤镜，需要把原数据经过处理后保存但是不显示数据 3.对于默认的相机，使用系统提供的OpenGL渲染的帧缓冲区（OES），OpenGL所有渲染结果直接到达帧缓冲区----&gt;on-Srceen渲染方式       对于贴纸相机，使用帧缓冲区对象，OpenGL将提供给窗口的帧缓冲区重定向FBO之中 4. FBO提供缓冲区：颜色缓冲区，深度缓冲区，模板缓冲区        FBO提供2种绑定的对象：纹理图片(texture images) 和 渲染图像(renderbuffer images)         4.1 纹理绑定FBO,OpenGL执行渲染到纹理操作        4.2 渲染绑定FBO，OpenGL执行离屏渲染        4.3 通过GL_MAX_COLOR_ATTACHMENTS查询颜色缓冲区挂节点        4.4 纹理对象 glFramebufferTexture2D            渲染对象 glFramebufferRenderbuffer 5. FBO (Frame Buffer Object) 帧缓冲区对象，FBO本身不能用于渲染，只有添加了纹理或者渲染缓冲区后才能作为渲染目标             6. FBO 使用流程图</code></pre><p><img src="/images/android/opengles/Android_OpenGLES_OES.png" alt="FBO"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><pre><code>#### 1.使用FBO处理图片滤镜### 2.使用FBO处理相机纹理    </code></pre>]]></content>
    
    
    <categories>
      
      <category>OpenGLES</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGLES</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Camera_GlSurfaceView</title>
    <link href="/2022/01/07/Android/Camera2/Camera2_GlSurfaceView/"/>
    <url>/2022/01/07/Android/Camera2/Camera2_GlSurfaceView/</url>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念:"></a>基本概念:</h3><p><img src="./OpenGLES_Camera_Screen_Orientation.png" alt="ScreenOrientation"></p><h3 id="打开相机"><a href="#打开相机" class="headerlink" title="打开相机"></a>打开相机</h3><p>怎么就一直加载不出图片</p><h3 id="显示相机"><a href="#显示相机" class="headerlink" title="显示相机"></a>显示相机</h3><h3 id="使用ImageReader"><a href="#使用ImageReader" class="headerlink" title="使用ImageReader"></a>使用ImageReader</h3><h3 id="Image转码"><a href="#Image转码" class="headerlink" title="Image转码"></a>Image转码</h3>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>相机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java_String</title>
    <link href="/2020/12/15/java/lang/String/"/>
    <url>/2020/12/15/java/lang/String/</url>
    
    <content type="html"><![CDATA[<h2 id="Char"><a href="#Char" class="headerlink" title="Char"></a>Char</h2><pre><code>1. String 底层实现为 char[]-----&gt;private final char value[]//char[] 数组2. String类为final类，也就是无法通过子类去继承。（final修饰的方法无法复写)</code></pre><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><pre><code>### 1. String 实现了接口列表    #### 1.1 java.io.Serialliable 序列化    #### 1.2 Comparable&lt;String&gt;----&gt;public int compareTo(String)  此接口用来设置排序的规则    #### 1.3 CharSequence### 2. String 内部实现    #### 2.1  private final char value[];//使用字符数组进行存储    #### 2.2  private int hash;//缓存字符串的哈希值### 3. String 方法    #### 3.1 String的构造方法中，涉及charset，使用到了StringCode类以及使用Arrays.copyof() 通过对char数组进行拷贝    </code></pre><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><pre><code>### 1. StringBuilder  A mutable sequence of characters.（可变序列序列），but with no guarantee of synchronization(但是无法保证同步)，used by a single thread,it will be faster under most implementation.### 2. StringBuilder 同样为final类，无法通过子类继承去修改实现,继承AbstractStringBuilder,       实现的接口列表                2.1 java.io.Serializable 序列化                2.2 CharSequence </code></pre><h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><pre><code>### 2. StringBuffer</code></pre><h2 id="延申知识"><a href="#延申知识" class="headerlink" title="延申知识"></a>延申知识</h2><pre><code>### 1. java.lang.Comparable的使用    o:specified object    return:    a negative integer  less than     zero                equal to    a positive integer  greater than     public int compareTo(T o);    查看String的源码发现实现此接口，String的比大小规则:两个字符串均从第一个字符起，比较字符的Unicode Value的大小    <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(<span class="hljs-keyword">String</span> anotherString)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len1 = value.length;<br>    <span class="hljs-keyword">int</span> len2 = anotherString.value.length;<br>    <span class="hljs-keyword">int</span> lim = Math.<span class="hljs-built_in">min</span>(len1, len2);<br>    <span class="hljs-keyword">char</span> v1[] = value;<br>    <span class="hljs-keyword">char</span> v2[] = anotherString.value;<br><br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (k &lt; lim) &#123;<br>        <span class="hljs-keyword">char</span> c1 = v1[k];<br>        <span class="hljs-keyword">char</span> c2 = v2[k];<br>        <span class="hljs-keyword">if</span> (c1 != c2) &#123;<br>            <span class="hljs-keyword">return</span> c1 - c2;<br>        &#125;<br>        k++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> len1 - len2;<br>&#125;<br></code></pre></td></tr></table></figure>### 2. 其他地方的使用    Lists (and arrays) of objects that implement this interface can be sorted automatically by Collection#sort(list) Collections.sort And Arrays.srot(Object[]) Arrays.sort.    这里提供集合对象的排序可以自动使用2个实现。    Collections.class    <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> Comparable&lt;? <span class="hljs-keyword">super</span> T&gt;&gt; <span class="hljs-keyword">void</span> <span class="hljs-keyword">sort</span>(List&lt;T&gt; list) &#123;<br>    list.<span class="hljs-keyword">sort</span>(<span class="hljs-keyword">null</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>    List.class    <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@SuppressWarnings</span>(&#123;<span class="hljs-string">&quot;unchecked&quot;</span>, <span class="hljs-string">&quot;rawtypes&quot;</span>&#125;)<br><span class="hljs-keyword">default</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">sort</span>(<span class="hljs-params">Comparator&lt;? <span class="hljs-built_in">super</span> E&gt; c</span>)</span> &#123;<br>    <span class="hljs-built_in">Object</span>[] a = <span class="hljs-built_in">this</span>.toArray();<br>    Arrays.sort(a, (Comparator) c);<br>    ListIterator&lt;E&gt; i = <span class="hljs-built_in">this</span>.listIterator();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">Object</span> e : a) &#123;<br>        i.next();<br>        i.set((E) e);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>    Arrays.class    ```        public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) &#123;            if (c == null) &#123;                sort(a);            &#125; else &#123;            if (LegacyMergeSort.userRequested)                legacyMergeSort(a, c);            else                TimSort.sort(a, 0, a.length, c, null, 0, 0);            &#125;        &#125;    ```     ### 3.CharSequence    3.1简介    &lt;tt&gt;CharSequence&lt;/tt&gt; is a readable sequence of &lt;code&gt;char&lt;/code&gt; values. This interface provides uniform, read-only access to many different kinds of &lt;code&gt;char&lt;/code&gt; sequences.     此接口提供对于char的可读序列，可以用来提供统一，仅读 对于各种各样的char序列(String,StringBuilder,StringBuffer)</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合</title>
    <link href="/2020/12/13/java/util/java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3/"/>
    <url>/2020/12/13/java/util/java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="源码类图"><a href="#源码类图" class="headerlink" title="源码类图"></a>源码类图</h2><p><img src="/images/java/Java_Util_Collections.png" alt="Java1.8"></p><h2 id="源码学习"><a href="#源码学习" class="headerlink" title="源码学习"></a>源码学习</h2><h3 id="1-List"><a href="#1-List" class="headerlink" title="1.List"></a>1.List</h3><h4 id="1-1-Vector"><a href="#1-1-Vector" class="headerlink" title="1.1 Vector"></a>1.1 Vector</h4><ul><li><p><a href="https://github.com/wupeixuan/JDKSourceCode1.8/blob/master/src/java/util/Vector.java">在线查看</a></p></li><li><p>Vector实现是数组，默认空构造方法长度为10，也可以根据传入initialCapacity</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Vector</span>(<span class="hljs-params">int initialCapacity, int capacityIncrement</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>();<br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span>+initialCapacity);<br>    <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>[initialCapacity];<br>    <span class="hljs-built_in">this</span>.capacityIncrement = capacityIncrement;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Vector</span>(<span class="hljs-params">int initialCapacity</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>(initialCapacity, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Vector</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>(<span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Vector使用时</p><ul><li><p>允许添加value是null</p></li><li><p>size(),isEmpty(),get(index),set(int,E),add() 方法的执行时间复杂度O(1),注意这里的关键字Synchronized</p>  <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> elementCount;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> elementCount == <span class="hljs-number">0</span>;<br>&#125;    <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (index &gt;= elementCount)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArrayIndexOutOfBoundsException(index);<br>    <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">elementData</span><span class="hljs-params">(index)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function">E <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (index &gt;= elementCount)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArrayIndexOutOfBoundsException(index);<br>    E oldValue = elementData(index);<br>    elementData[index] = element;<br>    <span class="hljs-keyword">return</span> oldValue;<br>&#125; <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    modCount++;<br>    ensureCapacityHelper(elementCount + <span class="hljs-number">1</span>);<br>    elementData[elementCount++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>线程是否安全？ 肯定的哈，这么多synchronized</p></li><li><p>扩容:看到这里发现了个”+”,原来是2倍</p>   <figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haxe">grow(minCapacity);<br><span class="hljs-keyword">private</span> void grow(int minCapacity) &#123;<br>    int oldCapacity = elementData.length;<br>    int <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = oldCapacity + ((capacityIncrement &gt; <span class="hljs-number">0</span>) ?<br>                                 capacityIncrement : <span class="hljs-type">oldCapacity</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> - minCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = minCapacity;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = hugeCapacity(minCapacity);<br>    elementData = Arrays.copyOf(elementData, <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>扩容本质:</p>  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span>copy<span class="hljs-constructor">Of(<span class="hljs-params">elementData</span>, <span class="hljs-params">newCapacity</span>)</span><br></code></pre></td></tr></table></figure></li><li><p>Vector看起来平常很少用哈！！！        </p></li></ul></li></ul><h4 id="1-2-ArrayList"><a href="#1-2-ArrayList" class="headerlink" title="1.2 ArrayList"></a>1.2 ArrayList</h4><ul><li><ul><li><a href="https://github.com/wupeixuan/JDKSourceCode1.8/blob/master/src/java/util/ArrayList.java">在线查看</a></li></ul></li><li><p>ArrayList实现是一个数组，默认长度10，size（int）表示长度。代码摘选如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACTITY=<span class="hljs-number">10</span>;<span class="hljs-comment">//默认长度</span><br><span class="hljs-keyword">transient</span> Object[] elementData;<span class="hljs-comment">//基本实现数组</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<span class="hljs-comment">//大小</span><br></code></pre></td></tr></table></figure></li><li><p>ArrayList 使用时</p><ul><li>允许添加value是null的值</li><li>size(),isEmpty(),get(index),set(),add()方法的执行时间复杂度均为O(1),这里的时间复杂度表示访问单个元素时，因为访问只需要一条指令。  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br><span class="hljs-comment">//返回List的大小实现</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">size</span>;<br>&#125;<br><br><span class="hljs-comment">//返回List是否为空</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">size</span> == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//根据index返回value</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    rangeCheck(index); <span class="hljs-comment">// 检查是否越界</span><br>    <span class="hljs-keyword">return</span> elementData(index);<span class="hljs-comment">// 返回ArrayList的elementData数组index位置的元素</span><br>&#125;<br><br><span class="hljs-comment">//设置index的value</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;<br>    rangeCheck(index); <span class="hljs-comment">// 检查是否越界</span><br>    E oldValue = elementData(index);<span class="hljs-comment">// 调用elementData(index)获取到当前位置的</span><br>    elementData[index] = element; <span class="hljs-comment">// 将element赋值到ArrayList的elementData数组的第index位置</span><br>   <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br><br><span class="hljs-comment">//添加一个值(在添加时未进行null判断，所有ArrayLsit是允许空值存在)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    ensureCapacityInternal(<span class="hljs-built_in">size</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// 扩容 // Increments modCount!!</span><br>    elementData[<span class="hljs-built_in">size</span>++] = e;   <span class="hljs-comment">// 将e赋值给elementData的size+1的位置</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;   <br></code></pre></td></tr></table></figure></li></ul></li><li><p>线程是否安全？ 不安全，这里并未看到对方法或者全局变量使用synchronized关键字。以及size并未使用volatile修饰</p></li></ul><ul><li>扩容规则<ul><li>扩容大小为原大小的1.5倍,后使用Arrays.copyof(old,new)  <figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">private</span> void grow(int minCapacity) &#123;<br>    int oldCapacity = elementData.length; <span class="hljs-comment">// 获取到ArrayList中elementData数组的内存空间长度</span><br>    int <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<span class="hljs-comment">// 扩容至原来的1.5倍</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> - minCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = minCapacity;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<span class="hljs-comment">//若预设值大于默认的最大值检查是否溢出</span><br>        <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = hugeCapacity(minCapacity);<br>    elementData = Arrays.copyOf(elementData, <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span>);<span class="hljs-comment">// 并将elementData的数据复制到新的内存空间</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>扩容的本质：  <figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">System.arraycopy(elementData, <span class="hljs-number">0</span>, <span class="hljs-keyword">new</span><span class="hljs-type">ElementData</span>, <span class="hljs-number">0</span>,Math.min(elementData.length,<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span>))<br></code></pre></td></tr></table></figure></li></ul></li><li>使用总结<ul><li>ArrayList删除时间复杂度为O(1),且允许删除null值</li><li>ArrayList全局变量且多线程使用时，存在问题.作为局部变量，放心用吧！！！</li><li>可以使用的Collections#synchronizedList保证线程安全</li><li>使用ArrayList时为了便面多次copy的过程,可以在初始化时指定固定大小</li></ul></li></ul><h4 id="1-2-LinkedList"><a href="#1-2-LinkedList" class="headerlink" title="1.2 LinkedList"></a>1.2 LinkedList<E></h4><ul><li><p><a href="https://github.com/wupeixuan/JDKSourceCode1.8/blob/master/src/java/util/LinkedList.java">在线查看</a></p></li><li><p>LinkedList底层数据结构是一个双向链表，既然是双向链表。可以被当作栈，队列。非线程安全</p>  <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">transient int <span class="hljs-attr">size=</span><span class="hljs-number">0</span>;<br>transient <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;E</span>&gt; first;//transient 防止序列化<br>transient <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;E</span>&gt; last;<br></code></pre></td></tr></table></figure></li><li><p>LinkedList 方法实现(这里只对思路和public方法记录下)</p><ul><li>头节点插入  <figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">private</span> void linkFirst(E e)&#123;<br>    final Node&lt;E&gt; f = first;<br>    final Node&lt;E&gt; <span class="hljs-keyword">new</span><span class="hljs-type">Node</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">Node</span>&lt;&gt;(<span class="hljs-literal">null</span>,e,f);<br>    first = <span class="hljs-keyword">new</span><span class="hljs-type">Node</span>;<br>    <span class="hljs-keyword">if</span>(f == <span class="hljs-literal">null</span>)<br>        last = <span class="hljs-keyword">new</span><span class="hljs-type">Node</span>;<br>    <span class="hljs-keyword">else</span><br>        f.prev = <span class="hljs-keyword">new</span><span class="hljs-type">Node</span>;<br>    size++;<br>    modCount++;    <br>&#125;<br></code></pre></td></tr></table></figure></li><li>尾节点插入(不做笔记)</li><li>在succ节点前插入  <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">void linkBefore(E e,<span class="hljs-keyword">Node</span><span class="hljs-title">&lt;E</span>&gt; succ)&#123;<br>    final <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;E</span>&gt; pred = succ.prev;//保存前一个节点<br>    final <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;E</span>&gt; newNode = new <span class="hljs-keyword">Node</span><span class="hljs-title">&lt;&gt;(pred</span>,e,succ);//创建一个新的节点<br>    succ.prev = newNode;//succ的前节点设置为newNode<br>    if(<span class="hljs-attr">pred=</span>=null)<br>        first = newNode;<br>    else<br>        pred.next = newNode;<br>    size++;<br>    modCount++;        <br>&#125;<br></code></pre></td></tr></table></figure></li><li>删除非空节点</li><li>获取首节点,并且返回头节点值  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> E <span class="hljs-function"><span class="hljs-title">getFirst</span>(<span class="hljs-params"></span>)</span>&#123;<br>    final Node&lt;E&gt; f = first;<br>    <span class="hljs-keyword">if</span>(f==<span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>    <span class="hljs-keyword">return</span> f.item    <br>&#125;<br></code></pre></td></tr></table></figure></li><li>获取尾节点，返回存储的元素值</li><li>在头节点插入</li><li>判断元素是否包含  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript">        <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">contains</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> o</span>)</span>&#123;<br>            <span class="hljs-keyword">return</span> indexOf(o)!=-<span class="hljs-number">1</span>;<br>        &#125;<br>    <span class="hljs-string">``</span><span class="hljs-string">` </span><br><span class="hljs-string">- 查询操作返回对应的Index</span><br></code></pre></td></tr></table></figure><pre><code>  public int indexOf(Object o)&#123;      int index = 0;      if(o==null)&#123;          for(Node&lt;E&gt; x= first;x!=null;x=x.next)&#123;              if(x.itme==null)                  return index;              index++;              &#125;      &#125;else&#123;          for(Node&lt;E&gt; x= first;x!=null;x=x.next)&#123;              if(o.equals(x.item))                  return index;              index++;              &#125;              &#125;  &#125;</code></pre>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">    - 获取头节点 peeK()<br>    - 获取并删除头节点 poll()<br>    - 等等（这些方法的实现还是比较简单，都是比较常规的操作)<br><span class="hljs-comment">### 2.Map</span><br><span class="hljs-comment">#### 2.1 HashMap</span><br>- [在线查看](https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/wupeixuan/</span>JDKSourceCode1.<span class="hljs-number">8</span><span class="hljs-regexp">/blob/m</span>aster<span class="hljs-regexp">/src/</span>java<span class="hljs-regexp">/util/</span>HashMap.java)<br>- HashMap底层数据结构<br><br>    数组+链表+红黑树，当链表的长度大于等于<span class="hljs-number">8</span>时，链表会转换成为红黑树，当红黑树的大小小于等于<span class="hljs-number">6</span>时，红黑树会转换成为链表。<br></code></pre></td></tr></table></figure>  static final int DEFAULT_ININIAL_CAPCITY=1&lt;&lt;4;//默认16<br>  static final int MAXIMUM_CAPACITY =1&lt;&lt;30;//最大<br>  transient Node&lt;K,V&gt;[] table;//存储数组的元素<br>  static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt;{}//红黑树的实现<br>  static class Node&lt;K, V&gt; implements Map.Entry&lt;K, V&gt;{}//链表的节点<br>```</li></ul></li><li></li></ul><h5 id="2-1-1-LinkedHashMap"><a href="#2-1-1-LinkedHashMap" class="headerlink" title="2.1.1 LinkedHashMap"></a>2.1.1 LinkedHashMap</h5><h4 id="2-2-TreeMap"><a href="#2-2-TreeMap" class="headerlink" title="2.2 TreeMap"></a>2.2 TreeMap</h4><h4 id="2-3-HashTable"><a href="#2-3-HashTable" class="headerlink" title="2.3 HashTable"></a>2.3 HashTable</h4><h4 id="2-4-EnumMap"><a href="#2-4-EnumMap" class="headerlink" title="2.4 EnumMap"></a>2.4 EnumMap</h4><h3 id="3-Set"><a href="#3-Set" class="headerlink" title="3.Set"></a>3.Set</h3><h4 id="3-1-HashSet"><a href="#3-1-HashSet" class="headerlink" title="3.1 HashSet"></a>3.1 HashSet</h4><h4 id="3-1-1-LinkedHashSet"><a href="#3-1-1-LinkedHashSet" class="headerlink" title="3.1.1 LinkedHashSet"></a>3.1.1 LinkedHashSet</h4><h4 id="3-2-TreeSet"><a href="#3-2-TreeSet" class="headerlink" title="3.2 TreeSet"></a>3.2 TreeSet</h4><h4 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h4>]]></content>
    
    
    <categories>
      
      <category>Java源码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo+Github+fluid搭建</title>
    <link href="/2020/12/12/my-site/"/>
    <url>/2020/12/12/my-site/</url>
    
    <content type="html"><![CDATA[<h2 id="Hexo-Github-fluid搭建记录"><a href="#Hexo-Github-fluid搭建记录" class="headerlink" title="Hexo+Github+fluid搭建记录"></a>Hexo+Github+fluid搭建记录</h2><h4 id="主体流程"><a href="#主体流程" class="headerlink" title="主体流程"></a>主体流程</h4><p>1.Github 注册账号,创建”*.github.io”的仓库<br>2.安装Node.js后,使用npm install hexo<br>3.修改默认theme为fluid</p><h3 id="需要参考的链接"><a href="#需要参考的链接" class="headerlink" title="需要参考的链接"></a>需要参考的链接</h3><p><a href="https://github.com/">Github</a><br><a href="https://nodejs.org/">Node.js</a><br><a href="https://hexo.io/zh-cn/">Hexo</a><br><a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a></p><h2 id="创建博客的原因"><a href="#创建博客的原因" class="headerlink" title="创建博客的原因"></a>创建博客的原因</h2><ol><li><p>一名Android开发</p><ol><li>日常记录<br>以上这些模块曾经已经整理详细学习记录（软件&amp;硬件知识)，希望在后续维护中，补充上来！！！</li></ol></li><li><p>其他知识模块如下</p><p> 2.1 Android Camera(相机应用)<br> 2.2 Android OpenGLES(图像处理)<br> 2.3 Android AI(TFLite)</p></li><li><p>学习方向<br> 3.1 美颜算法了解和学习<br> 3.2 算法题</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具使用记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/12/12/hello-world/"/>
    <url>/2020/12/12/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
